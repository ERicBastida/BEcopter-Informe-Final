%---------------------------------------------------------------------
%
%                          Cap�tulo 4
%
%---------------------------------------------------------------------
%
% 
% Copyright 2009 Marco Antonio Gomez-Martin, Pedro Pablo Gomez-Martin
%
% This file belongs to the TeXiS manual, a LaTeX template for writting
% Thesis and other documents. The complete last TeXiS package can
% be obtained from http://gaia.fdi.ucm.es/projects/texis/
%
% Although the TeXiS template itself is distributed under the 
% conditions of the LaTeX Project Public License
% (http://www.latex-project.org/lppl.txt), the manual content
% uses the CC-BY-SA license that stays that you are free:
%
%    - to share & to copy, distribute and transmit the work
%    - to remix and to adapt the work
%
% under the following conditions:
%
%    - Attribution: you must attribute the work in the manner
%      specified by the author or licensor (but not in any way that
%      suggests that they endorse you or your use of the work).
%    - Share Alike: if you alter, transform, or build upon this
%      work, you may distribute the resulting work only under the
%      same, similar or a compatible license.
%
% The complete license is available in
% http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
%---------------------------------------------------------------------

\chapter{Prueba integral de la plataforma y del cuadric�ptero}

\label{cap4:pruebas}

\begin{FraseCelebre}
\begin{Frase}
Divide et Impera
\end{Frase}
\begin{Fuente}
Julio Cesar
\end{Fuente}
\end{FraseCelebre}

\begin{resumen}
	En el presente cap�tulo se describir� todo el proceso realizado de la fase denominada \textbf{ Prueba integral de la plataforma y del cuadric�ptero} que forma parte del actual proyecto. En esta fase se contempla la tarea de \textit{Evaluar el funcionamiento del cuadric�ptero y de la plataforma} con el fin de satisfacer los requerimientos estipulados y de manera complementaria que el sistema se comporte de forma estable. 

\par Al momento de encargar el desarrollo de cualquier tipo de proyecto y estemos avanzando en sus respectivas fases es necesario comprobar que el funcionamiento de lo que se va desarrollando est� cumpliendo con los resultados esperados, ya que de no ser as�, la continuidad del mismo se ver� afectada. Por tal motivo, en las siguientes secciones se detallar�n los distintos tipos de pruebas que han sido ejecutadas luego de codificar alguna funcionalidad del mismo. Cabe mencionar que por la naturaleza del proyecto que estamos desarrollando es importante que el mismo se comporte exactamente a los requerimientos estipulados y que adem�s, el software proporcione mecanismos de seguridad en caso de que ocurriese alguna inconsistencia, ya que podr�a provocar accidentes que da�en el equipo como tambi�n a las personas que se encuentren en la intersecci�n de su trayectoria. Dicho esto, introduciremos el concepto de  \textbf{Aseguramiento de la calidad} en las pr�ximas secciones. 

\end{resumen}


\section{Conceptos preliminares}

El\textbf{ plan de QA} atraviesa el proceso de desarrollo desde el nacimiento de la idea hasta la implementaci�n del software.  En las primeras etapas, verifica que los objetivos est�n bien planteados y los requerimientos sean precisos. En las fases de dise�o y codificaci�n, vigila el cumplimiento de los est�ndares fijados. Finalmente, revisa que el software en funcionamiento respete los requerimientos pedidos y que la entrega al cliente se haga en las condiciones adecuadas.

El responsable del QA se tendr� que basar en conjunto de pruebas de calidad, entre las que se incluyen:

\begin{itemize}
	
	\item \textbf{Testeo unitario:} se prueba que cada m�dulo funcione bien por separado.
	\item \textbf{Prueba de estr�s :} se prueba la resistencia de la aplicaci�n envi�ndole una cantidad de peticiones excesiva, buscando que colapse.
	\item \textbf{Test de integraci�n:} los m�dulos probados independientemente durante el testeo unitario se acoplan y se prueban en conjunto.
	\item \textbf{Test funcional:} se prueba que el software ofrezca las funciones solicitadas.
	\item \textbf{Test de aceptaci�n:} el usuario verifica que el producto satisfaga sus expectativas. En este caso, como se trata de una necesidad que inicialmente ha surgido de integrantes del \textit{sinc(i)} el software ser� validado por dichos responsables y una vez que el producto est� finalizado, y con el objetivo de que �ste cumpla de manera eficaz con todas sus funcionalidades, el mismo ser� publicado en una plataforma de desarrollo colaborativo con el fin de que �ste realice un \textit{feedback} de las inconsistencias y/o errores del mismo. 
	
\end{itemize}


Las pruebas de QA no s�lo son beneficiosas para el usuario final que recibir� un producto de calidad, sino tambi�n para el ejecutor del proyecto, ya que al establecer un control permanente sobre el proceso evitar� en buena medida los costos de tener que corregir errores en etapas avanzadas del proyecto.

\newpage

\section{Evaluaci�n funcional del Cuadric�ptero y la Plataforma}

\subsection{Verificaci�n y validaci�n de la plataforma}

Para el desarrollo del proyecto, se ha utilizado un paradigma de programaci�n \textit{orientado a objetos}. Este paradigma nos ha facilitado la divisi�n l�gica de las funcionalidades y por lo tanto, nos ha sido de gran facilidad probar cada componente l�gico una vez codificado. Para validar y verificar que las funcionalidades cumplan con las especificaciones del cliente; se realiza el siguiente \textbf{plan de QA}.

En primera instancia se valida con el documento de requerimientos y con el diagrama de clases generado en etapas anteriores. Se examina de manera general que cumpla con las necesidades de los usuarios y, en caso de encontrar inconsistencias que no cumplen completamente dicha necesidad se procede a modificar el diagrama de clases. Una vez codificadas dichas clases, se procede a realizar los siguientes niveles de prueba:\newline



\begin{itemize}
	\item \textbf{ [Descripci�n] Nivel 0 } 
	
	\par Por funcionalidad se implementan las pruebas unitarias, realizando el siguiente procedimiento: 
	\par Se ingresan datos reales o verdaderos en las entradas de las funciones codificadas, y luego de ejecutarla, observamos si obtuvimos los resultados deseados. A partir de aqui podemos obtener 2 casos, que la funci�n se comporte seg�n lo esperado o que la misma contenga errores. En caso de contenerlos se procede a solucionarlo siempre y cuando  al momento de obtener dicha soluci�n la misma no conlleve demasiado tiempo y no sea dependiente de otras tareas; se registra dicho inconveniente con su respectiva fecha de incidencia y sus posibles riesgos para ser resuelta en etapas posteriores.
	Por otro lado y una vez obtenido los resultados con los datos verdaderos se procede a cambiar el tipo de entrada por datos err�neos o posibles alternativas, como por ejemplo , datos n�mericos en vez de texto, caracteres especiales, datos fuera de rango, etc. con el fin de ``proporcionar robustez a nuestro c�digo'' (prueba de estr�s) y adaptar el c�digo para  mantener el control en caso de ocurrir algun tipo de error. Cabe mencionar, que s�lo se suspenden temporalmente funcionalidades, si se consideran de tipo \textit{no funcionales} o no resuelve completamente un requerimiento del usuario. En la Figura \ref{fig:nivel-0} se esquematiza con un diagrama de flujo este procedimiento. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.4\textheight]{Imagenes/Nivel0}
		\caption{Plan de QA - Nivel 0}
		\label{fig:nivel-0}
	\end{figure}
	
	\newpage
	
	\item \textbf{[Descripci�n] Nivel 1 }
	
	En este nivel lo que se busca es realizar los test de integraci�n y funcionales (una vez ya finalizados los test del nivel 0), para esto se procede de la siguiente manera:
	En el mismo m�dulo, se instancia cada clase perteneciente al mismo y se prueban las funcionalidades que dependen de otras clases (ya que las funcionalidades que no dependen de otras ya han sido probadas) y se toma el mismo procedimiento por funcionalidad que en el Nivel 0. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.3\textheight]{Imagenes/Nivel1}
		\caption{Plan de QA - Nivel 1}
		\label{fig:nivel1}
	\end{figure}
	
	\item \textbf{[Descripci�n] Nivel 2}
	
	Este nivel es el �ltimo que se realiza, tiene como principal objetivo cumplir con los test de aceptaci�n (considerando temporalmente que el programador es el usuario final); para realizar esto se tiene como prioridad que la interacci�n entre el veh�culo y el software se comporte correctamente, con esto hacemos referencia a que se muestren los resultados correspondientes, como se�al de GPS, bater�a desenchufada, veh�culo desconectado de la red, que el recibimiento de los comandos se puedan comprobar con las revoluciones de los motores, etc. En caso de encontrar alg�n tipo de falla o desperfecto, nos dirigimos directamente hasta el nivel 0 y desde ah� se procede a repetir el procedimiento. 
	
	% TODO: Falta agregar que luego se lleva a cabo la solucion de los problemas pendientes
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.3\textheight]{Imagenes/Nivel2}
		\caption{Plan de QA - Nivel 2}
		\label{fig:nivel2}
	\end{figure}
	
	
	
\end{itemize}



\subsection{Verificaci�n y validaci�n del cuadric�ptero}

M�s all� que el concepto del plan de QA se aplique com�nmente en el desarrollo de software, es posible crear un punto de intersecci�n y adoptar la misma estructura l�gica en donde se realizan los distintos tipos de pruebas que en el plan creado; pero en este caso sobre los elementos electr�nicos. Con esto hacemos refencia, que podemos ver a cada componente electr�nico como un m�dulo, por el cual nosotros como QA lo conceptualizamos como una \textbf{caja negra}, en donde ingresan  datos de entrada y deber�amos obtener determinados datos de salida. Estos datos  pueden ser obtenidos por sus correspondientes fabricantes que proporcionan en su gran mayor�a el \textit{data-sheet} de cada componente. 
Por lo tanto en lo que concierne a esta secci�n se explicar� el procedimiento utilizado para probar el correcto funcionamientos de cada componente antes de ponerlos en marcha de manera conjunta. 


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth, height=0.6\textheight]{Imagenes/esquema-hardware}
	\caption{Esquema de conexiones el�ctricas del cuadric�ptero}
	\label{fig:esquema-hardware}
\end{figure}

\subsubsection{Conectores}

Los conectores o cables, son los encargados de comunicar o transportar las se�ales a cada entrada/salida entre componentes electr�nicos, por tal raz�n es de suma importancia evaluar su estado, ya que cumplen un rol importante al transportar la informaci�n. Para determinar el estado de cada conector se utiliz� el tester en modo "comprobaci�n de continuidad", como se puede ver en la Figura \ref{fig:testermodocont},  el cual conectando las puntas del cable con las puntas del tester, nos indicar� con un sonido cuando el cable se encuentre en buenas condiciones, en caso contrario se intenta repararlo o desecharlo en el peor de los casos.

\begin{figure}
	\centering
	\includegraphics[width=0.6\linewidth, height=0.3\textheight]{Imagenes/testerModoCont}
	\caption{Mult�metro digital}
	\label{fig:testermodocont}
\end{figure}



\subsubsection{Fuentes de alimentaci�n}

En lo que respecta a las pruebas, hay que hacer foco en que es necesario disponer de un uso considerable de los componentes, ya que probar cada funcionalidad conlleva realizar pruebas continuas y por lo tanto al ser componentes electr�nicos el suministro de energ�a en esta etapa deben ser , ``ilimitado''. Es por tal raz�n que la portabilidad que disponemos al tener bater�as es innecesaria (m�s all� que ser�n �tiles al momento de realizar vuelos a distancia),  por lo tanto estas bater�as son reemplazadas por fuentes transformadoras de energ�a, las cuales dependen del suministro de energ�a de tipo alterna proveniente de las instalaciones del domicilio del ejecutante, lde esta manera nos da independencia en ell tiempo de uso de los componentes. En la Figura \ref{fig:esquema-hardware} los componentes etiquetadas con los n�meros 1 y 4 corresponden a las bater�as que deben tener las siguientes especificaciones seg�n los dispositivos electr�nicos que alimentan:
%TODO: el diagrama fue reeemplazado sin querer por el diagrama viejo, donde esta mal el cableado

\begin{itemize}
	\item \textbf{Bater�a 1: } La misma provee de energ�a a la placa Arduino UNO. Por lo tanto, seg�n las especificaciones de Arduino
	debe recibir los siguientes suministros \footnote{https://store.arduino.cc/usa/arduino-uno-rev3} :
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline 
			\multicolumn{2}{|c|}{\textbf{Especificaciones Arduino UNO}} \\ 
			\hline 
			Voltaje operativo & 5 [Volts] \\ 
			\hline 
			Entrada de voltaje (recomendado)  & 7 - 12  [Volts] \\ 
			\hline 
			Entrada de voltaje (limites) & 6 - 20 [Volts] \\ 
			\hline 
		\end{tabular} 
	\end{center}
	Para reemplazar esta bater�a se ha utilizado una fuente transformador de 7 Volts y 800mA, como se puede observar en la Figura \ref{fig:fuentearduino}
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.4\linewidth, height=0.2\textheight]{Imagenes/fuenteArduinoo}
		\caption{Fuente de alimentaci�n para Arduino UNO 7 [Volts] - 800[mA]}
		\label{fig:fuentearduino}
	\end{figure}
	
	
	
	
	\item \textbf{Bater�a 4: } La segunda bater�a como se puede ver en la Figura \ref{fig:esquema-hardware} provee de energ�a a los 4 motores  y adem�s alimenta de manera paralela a la placa Navio2/Raspberry Pi. Y por el otro lado tenemos los motores HobbyKing que reciben los siguientes suministros:
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline 
			\multicolumn{2}{|c|}{Especificaciones motor} \\ 
			\hline 
			Voltaje de entrada & 7.4 - 14.8 [Volts] \\ 
			\hline 
			Bater�as & 2-4 c�lula Lipo / 5-12 de la c�lula de Ni-XX \\ 
			\hline 
		\end{tabular} 
	\end{center}
	
	%\footnote{https://hobbyking.com/es_es/hobbyking-30a-blueseries-brushless-speed-controller.html?___store=es_es} 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.6\linewidth, height=0.25\textheight]{Imagenes/fuente12A}
		\caption{Fuente de alimentacion Nitto de 12v - 5A}
		\label{fig:fuente12a}
	\end{figure}
	
	Para reemplazar la alimentaci�n proveniente de dicha bater�a se ha adquirido una fuente de alimentaci�n como se puede observar en la Figura \ref{fig:fuente12a}, la cual ser� responsable de alimentar a los 4 motores y como se explicar� m�s adelante al Radio Control.
	
	
	
	
	Por �ltimo debemos alimentar a nuestra Raspberry Pi / Navio2 \footnote{https://emlid.com/navio/} que recibe los siguientes valores 
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline 
			\multicolumn{2}{|c|}{\textbf{Especificaciones Navio2}} \\ 
			\hline 
			Entrada de voltaje   & 4.75 - 5.25  [Volts] \\ 
			\hline 
			Consumo promedio & \< 150 [miliAmperes] \\ 
			\hline 
		\end{tabular} 
	\end{center}
	
	En este caso para alimentar a las placas se nos ha suministrado un transformador incluido en la compra de nuestra Raspberry Pi 3 con las siguientes especificaciones:
	5V y 2500mA, como se puede observar en la Figura \ref{fig:fuentenavio2}.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.4\linewidth, height=0.2\textheight]{Imagenes/fuenteNavio2}
		\caption{Fuente de alimentaci�n para la Navio2 con 5V y 2500mA}
		\label{fig:fuentenavio2}
	\end{figure}
	
\end{itemize}

Para comprobar que los respectivos valores de salida de cada fuente sean correctos y no provengan con alg�n tipo de falla t�cnica, se procede a medir los voltajes correspondientes con un tester, d�ndonos como resultado valores dentro del rango de especificaciones de f�brica.



\newpage

\subsubsection{Radio Control}

La comprobaci�n del radio control en primera instancia se reemplazan las 8 bater�as de 1.5v, con lo cual  tenemos una cantidad suministrada de 12V necesarios para alimentarlo, siendo justamente la misma cantidad de Voltaje proveniente de nuestra fuente de alimentaci�n de la Figura \ref{fig:fuente12a}. Luego de conectar la fuente se procede a controlar que las se�ales enviadas por lo movimientos del Joystick de control lleguen de manera correcta al receptor de se�al. Para realizar dicho procedimiento se deber�a medirlo mediante un osciloscopio y ver de manera precisa la forma de la se�al. Pero al no contar con dicho instrumento se analizan los pines con el tester midiendo el voltaje de la corriente continua, y se observa que al producir movimientos en los joystick cada pin en promedio muestra un voltaje cercano a los 5 Volts. Exceptuando el primer pin (el que corresponde al Eje x del primer joystick) donde no se observan valor de voltaje significativos. De esta manera, se tendr� en cuenta dicha falencia para las pr�ximas pruebas.  


\subsubsection{Motores}
En la prueba de motores se tuvo que codificar un script  \ref{script:motor}para que sea ejecutado sobre la placa Arduino. Una vez codificado dicho script se procedi� a realizar sus respectivas conexiones como se puede observar en la Figura \ref{fig:testmotor}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/testMotor}
	\caption{Esquema de conexiones para realizar prueba del motor}
	\label{fig:testmotor}
\end{figure}



\newpage

\begin{lstlisting}[language=C++]{Name=test2}\label{script:motor}
/* Programacion de un ESC con Arduino
*
* La velocidad del motor puede cambiarse enviando
* un entero entre 1000 (vel. minima) y 2000 (vel. max.)
* por Serial.
*
*/
#include<Servo.h>

//Crear un objeto de clase servo
Servo ESC; 

//Amplitud del pulso
int vel = 2000; 


void setup()
{
//Asignar un pin al ESC
ESC.attach(9);

//Activar el ESC -> 1000 = 1ms
ESC.writeMicroseconds(1000); 

//Esperar 5 segundos para hacer la activacion
delay(5000); 

//Iniciar puerto serial
Serial.begin(9600);
Serial.setTimeout(10);
}


void loop()
{
if(Serial.available() >= 1)
{
vel = Serial.parseInt(); //Leer un entero por serial
if(vel != 0)
{
//Generar un pulso con el numero recibido
ESC.writeMicroseconds(vel); 
}
}
}
\end{lstlisting}
\newpage

En la Figura \ref{fig:motortest} (que fue obtenida mediante el m�dulo de representaci�n de datos en etapas posteriores) se puede observar una gr�fica de tiempo vs rpm

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/motor_test}
	\caption{Gr�fico tiempo-RPM de los motores probados con el script}
	\label{fig:motortest}
\end{figure}




\subsubsection{Raspberry Pi - Navio2}

La prueba de funcionamiento de dichas placas se comprueba con la interacci�n con el software desarrollado. 

\subsubsection{Arduino}
En lo que compete a la placa Arduino, en el esquema presentado en la Figura \ref{fig:esquema-hardware} la misma cumple la funci�n de un conversor PWM a PPM, el cual es el formato de se�al necesario para que la placa Navio2 interprete las se�ales enviadas por el radio-control.  En nuestro caso y en el orden en que venimos describiendo las secciones, ya se han probado los dispositivos conectados al mismo, por lo tanto s�lo nos queda corroborar que el tipo de se�al enviada sea el correcto. Para realizar esta prueba es necesario contar con un osciloscopio, que muestre el tipo de se�al enviada por el pin configurado en la placa Arduino. Como no disponemos moment�neamente de un osciloscopio, se recurre a la simulaci�n; de manera que se utiliza el software de la siguiente p�gina web  www.library.io, el cual proporciona un simulador de c�digo y adem�s nos da la posibilidad de mostrar la se�al generada por un osciloscopio digital.   	
Luego de corroborar que la se�al es correcta mediante el programa de simulaci�n, se mide mediante un tester que la corriente promedio de salida se mantenga en un valor aceptable de voltaje para comprobar que la placa este funcionando correctamente.
Por �ltimo, en la Figura \ref{fig:todoconectado} se puede apreciar todo el sistema conectado seg�n el diagrama de la Figura \ref{fig:esquema-hardware}. Exceptuando los motores, que han sido debidamente desconectados al momento de realizar las pruebas; y �nicamente se ha conectado un motor sobre una base de madera, con el fin de mantener el mismo inm�vil al momento de enviar las �rdenes de arrancar. 
\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth, height=0.2\textheight]{Imagenes/todoConectado}
	\caption{Conexiones terminadas}
	\label{fig:todoconectado}
\end{figure}

\newpage

\subsection{Prueba integral}
Por �ltimo y ya probado que tanto la plataforma como el veh�culo est�n en condiciones, se procede a realizar las pruebas integrales entre ambas partes (nuestra aplicaci�n con el veh�culo). Para esto se descomponen dichas pruebas en categor�as o "m�dulos" que se han definido en el comienzo del proyecto por los \textit{stakeholders}.


\subsubsection{Conexi�n }
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/pConexion}
	\caption{M�dulo de conexi�n del proyecto}
	\label{fig:pconexion}
\end{figure}

El m�dulo de conexi�n es el encargado de habilitar y mantener toda la comunicaci�n entre el veh�culo y nuestro software, por lo tanto �ste debe ser lo bastante robusto para interpretar los principales errores producidos por la red de comunicaci�n elegida. El siguiente c�digo muestra la funcionalidad principal que se encarga de conectarse con nuestro veh�culo y mediante los try-except gestiona el control de errores proporcionando al usuario (en caso de generarse alguno) su respectivo mensaje informativo.

\begin{lstlisting}[language=python]
try:
if port_host != None:
# Concatenamos la direccion IP con el puerto
source = ip_host + ":" + port_host
else: 
# En caso de entrar aqui es porque se ha ingresado un puerto serial
source = ip_host
# Utilizamos la funcion connect de DroneKit
self.v = connect(source, 
wait_ready=True, 
heartbeat_timeout=10,
status_printer=logging.info)  		
# El parametro wait_ready = True garantiza que connect () no volvera 
# hasta que Vehicle.parameters y la mayoria de los otros atributos
# predeterminados se hayan rellenado con valores del vehiculo.

logging.info("Se ha conectado con la direccion {} de manera exitosa".format(source))

self.__on = True
self.descargarMisiones(False)

# Error TCP connection
except socket.error:
logging.info('No se ha encontrado el vehiculo, por favor compruebe la conexion')
raise WindowsError('No se ha encontrado el vehiculo, por favor compruebe la conexion')

# Error TTY connection
except exceptions.OSError as e:
logging.info('No se pudo establecer conexion con el puerto serial')
raise WindowsError('No se pudo establecer conexion con el puerto serial')
return
except APIException:
logging.info('Se ha excedido el tiempo de espera para establecer la conexion!')
raise WindowsError('Se ha excedido el tiempo de espera para establecer la conexion!')

except :
logging.info('Ha ocurrido un error inesperado. ')
raise WindowsError('Ha ocurrido un error inesperado. ') 

\end{lstlisting}

Seg�n el c�digo mostrado, podemos realizar una conexi�n con nuestro veh�culo mediante un dispositivo que se conecte por puerto serial o a trav�s de la red, ya sea mediante Ethernet o Wirreless (utilizando UDP). 

\begin{itemize}
	
	\item \textbf{Conexi�n mediante el puerto serial: } Para comprobar el funcionamiento, se han realizado anteriormente pruebas de conexi�n utilizando el protocolo SSH, el cual nos permite interactuar mediante una consola de comandos con nuestro veh�culo, d�ndonos los datos solicitados sin ning�n tipo de problema. Cabe mencionar que el objetivo de este tipo de conexi�n es utilizar los m�dulos inal�mbricos XBee/LoRa. 
	
	\item \textbf{Conexi�n mediante la red local: } Por comodidad al momento de transportar el veh�culo en los lugares en que la fuente de alimentaci�n necesitaba conectarse, este tipo de conexi�n nos ha resultado la m�s beneficiosa. El mismo utiliza un Router TP LINK TL-WR841N con una cantidad de 10 clientes conectados de manera inal�mbrica en el domincilio utilizado. Adem�s, se han realizado las mismas pruebas pero dentro de las instalaciones del \textit{sinc(i)} con una cantidad de 50 clientes  conectados aproximadamente al mismo router de pruebas. Y para este caso, la conexi�n sufr�a de varias interrupciones continuas.  Por lo que obtenemos como conclusi�n para estos casos que el router utilizado para el envio de comandos no debe ser utilizados por muchos usuarios, que de ser as� la conexi�n no ser� la optima.
	%TODO consultar que cantidad de clientes tiene la red aproximadamente
\end{itemize}

\textbf{Pruebas de interrupci�n de conexi�n}

Un aspecto importante a tener en cuenta, es el momento en que la conexi�n se corta. Por tal inconsistencia que puede ocurrir f�cilmente  se han realizado pruebas simulando dicho fen�meno y comprobando c�mo se comporta el software y el veh�culo al ocurrir este hecho. 
Cuando este inconveniente se presente, tanto el veh�culo como el software comparten una variable en com�n llamada \textit{last heartbeat}, la cual contiene informaci�n sobre el tiempo (en segundos) en que ha recibido su �ltimo mensaje proveniente del veh�culo.

\begin{lstlisting}[language=python]

# Testing on SITL indicates that last_heartbeat averages about .5 seconds,
# but will rarely exceed 1.5 seconds when connected. 
# Whether heartbeat monitoring can be useful will very much depend on the application.

if self.v.last_heartbeat > 1 and self.v.last_heartbeat <= 1.5 :
estados['signal'] = None
elif self.v.last_heartbeat <= 1 and self.v.last_heartbeat :
estados['signal'] = True
else:
estados['signal'] = False	
\end{lstlisting}


En el c�digo anterior se puede observar que existe una variable correspondiente al estado de la se�al, el mismo puede contener 3 valores: [False, None, True]. En caso de tener el valor de False, esto quiere decir que la conexi�n se ha perdido, ya que se ha superado el rango establecido; cuando el valor de \textit{last heartbeat} est� comprendido entre 1 y 1.5 segundos, tendr� un estado None, el mismo significa que est� dentro de valores de precauci�n ya que est� recibiendo mensajes con un poco de demora. Y por �ltimo en caso de estar en valores normales de tiempo tendr� un valor de True, indicando que estamos recibiendo informaci�n a tiempo del veh�culo, esta estructura simula el comportamiento de un sem�foro. 


\begin{itemize}
	\item \textbf{Comportamiento del veh�culo: } Como mencionamos, la variable \textit{last hearbeat} es compartida entre el software y el veh�culo. Por lo tanto cuando el veh�culo detecte que se ha perdido la conexi�n tenemos 3 posibilidades:
	\begin{enumerate}
		\item \textbf{Aterrizar}						
		\item \textbf{Volver al inicio}
		\item \textbf{Quedarse suspendido en el aire}
	\end{enumerate}
	
	Por defecto el veh�culo estar� en suspensi�n en el aire (siempre y cuando el nivel de bater�a lo permita) y en caso de agotar la bater�a, se proceder� a aterrizar el veh�culo. Se procede de esta forma ya que se considera que el veh�culo puede encontrarse en una zona no apta para aterrizar, como por ejemplo sobre una edificaci�n, un r�o, �rbol, etc. El mismo puede llegar a estropearse, por lo tanto seguir� pendiente hasta que la conexi�n se restablezca y en el �ltimo de los casos se procede a aterrizar (ya que se supone el problema de que el equipo de comunicaci�n se estropee o el mismo software cierre inesperadamente su ejecuci�n por alg�n motivo). Es importante a tener en cuenta que estas acciones pueden ser cambiadas en la respectiva configuraci�n de la aplicaci�n. 
	
	\item \textbf{Comportamiento del software: } Cuando este inconveniente se presente, el software, en primera instancia, tratar� de reconectarse por un tiempo estipulado (5 segundos)  y en caso de no poder restablecer� el estado del programa al mismo que cuando se inicia la aplicaci�n en primera instancia, con el objetivo de deshabilitar las funciones dependientes del veh�culo y dejar a disposici�n del usuario volver a conectarse en caso de ser necesario. 
\end{itemize}  


\subsubsection{Representaci�n de datos} 

La visualizaci�n de los datos es un aspecto importante cuando estamos controlando alg�n objeto a distancia, ya que es necesario conocer el estado del mismo, y con mayor importancia cuando el objeto no est� en nuestro campo visible. Por tal motivo se han realizado varias pruebas sobre los m�dulos de representaci�n de datos, con el prop�sito de que �stos muestren fielmente los datos capturados por el veh�culo en tiempo real.
\begin{itemize}
	\item \textbf{Gr�fico temporal de datos: }	El objetivo de este m�dulo de software en nuestro proyecto, como su nombre lo dice, es poder representar la evoluci�n temporal de los datos provenientes de alg�n sensor o estado del veh�culo mediante una gr�fica. 
	\par Seg�n lo especificado en el ERS, se ha propuesto utilizar la librer�a Vispy\footnote{Sitio web de Vispy http://vispy.org/}, esta librer�a escrita en Python  est� dise�ada espec�ficamente para la visualizaci�n interactiva de gran cantidad de datos de forma r�pida, escalable y f�cil.  Pero m�s all� de sus prestaciones, al momento de realizar las \textbf{pruebas de integraci�n} se ha observado que el rendimiento de nuestro software se ha reducido considerablemente; esto es debido a que Vispy utiliza distintas tecnolog�as al renderizar las figuras, por lo que se debi� incrustar dicho gr�fico de manera brusca para poder ver su funcionamiento. Al momento de querer optimizar dicho rendimiento, al ser Vispy una librer�a nueva,  su documentaci�n y por lo tanto su comunidad es escasa, y como es de esperar no se encontraba la ayuda necesaria para poder solventar los problemas presentes. Por tales motivos se recurre a la b�squeda de alguna alternativa que se adapte a nuestras necesidades; luego de encontrar y analizar las librer�as disponibles se llega a la decisi�n de utilizar PyQtGraph\footnote{Sitio web de PyQtGraph http://pyqtgraph.org/}. Esta librer�a adem�s de todas su prestaciones en el �mbito cient�fico / matem�tico / aplicaciones ingenieriles, est� construida con las mismas librer�as que utilizamos en nuestro proyecto, que es PyQt\footnote{Sitio Web de PyQt https://riverbankcomputing.com/software/pyqt/intro}. Por lo tanto, esto gener� una excelente adaptabilidad y rendimiento al momento de realizar las pruebas de integraci�n.  
	Para las \textbf{pruebas unitarias/estr�s/funcionales} se ha creado el m�dulo \textit{GraphDatav2}, el cual ha sido puesto en prueba hasta su m�ximo potencial. Utilizando una se�al de tipo aleatoria como datos de prueba (ya que el mismo contiene una gran cantidad de componentes frecuenciales en su dominio) y se ha generado su respectiva transformada de Fourier (utilizando la Transformada R�pida de Fourier), con el fin de corroborar que los calculos de los mismo no ralenticen el funcionamiento del mismo, pero luego de realizar las pruebas nos suministro de  resultados  dentro de las espectativa de rendimiento. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/pINICIO_b}
		\caption{M�dulo de representaci�n de datos}
		\label{fig:piniciob}
	\end{figure}
	
	
	\item \textbf{HUD: } A diferencia del m�dulo anterior, su responsabilidad es mostrar al usuario de manera instant�nea los estados sobre los componentes integrados al veh�culo, como tambi�n algunos de sus respectivos valores. Por lo tanto, m�s all� de sus pruebas unitarias/funcionales/estr�s/integraci�n aqu� entra en juego las pruebas de aceptaci�n proporcionadas por ``los pilotos de los veh�culos'', ya que el mismo debe ser indispensable al momento de mostrar los valores que ayuden al piloto del veh�culo en tener un conocimiento general del mismo en plena ejecuci�n. As� que de manera preventiva se ha desarrollado el mismo imitando en lo mejor posible a los HUD's reales, con el fin de tener una base de dise�o que sea v�lida en la vida real. 
	Con respecto a las pruebas de integraci�n hemos detectado que no cumple con nuestras necesidades de rendimiento, esto causa que el software se ralentice y no pueda interpretar ``en tiempo real'' la informaci�n recibida del veh�culo como tambi�n los comandos enviados. Por lo que se decidi� temporalmente deshabilitar algunas caracter�sticas del HUD hasta que se encuentre su respectiva soluci�n. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.5\linewidth, height=0.2\textheight]{Imagenes/HUD}
		\caption{Head Up Display}
		\label{fig:hud}
	\end{figure}
	
	
\end{itemize}

\subsubsection{Control del veh�culo}

El control del veh�culo, ya sea de forma manual o autom�tica, es una de las funcionalidades principales de este software. En lo que es el control manual, consiste en estar consultando constantemente los eventos producidos por un Joystick y seg�n una respectiva pre-asignaci�n se ejecuta un comando sobre el veh�culo. Y en el caso del control autom�tico, se requiere que se env�en un conjunto de misiones pre-configuradas y al ser recibidas por el veh�culo, que el mismo las ejecute.

\begin{itemize}
	
	\item \textbf{Control Manual:} Para poder ejecutar las pruebas del funcionamiento del control manual, es indispensable que el m�dulo de comunicaci�n funcione correctamente, ya que el control manual depende del mismo. Al momento de ejecutar las pruebas unitarias, entran en juego varias clases, como lo son la clase Veh�culo y Joystick. Por lo tanto se ha realizado en primera instancia el control manual con env�o de acciones con una duraci�n definida de tiempo, simulando la interacci�n con el joystick, y para determinar si los comandos han sido interpretados por el veh�culo se ha analizado la evoluci�n temporal del giro de los motores (utilizando el m�dulo de representaci�n de datos) medido en [rpm], y mostr�ndonos resultados aceptables y razonables como se puede ver en la Figura \ref{fig:testmotor}
	
	
	Luego de comprobar el correcto funcionamiento de los motores seg�n comandos limitados en tiempo, se inicia el proceso de pruebas con el joystick. En este caso se utiliza una clase auxiliar \textit{Capturador} que ha sido creada con el fin de ejecutarse en un hilo de ejecuci�n independiente para no congestionar el procesamiento de manera secuencial o interrumpir el hilo de ejecuci�n padre . En el siguiente c�digo podemos apreciar su funcionamiento:
	
	
	\begin{lstlisting}[language=python]
	class Capturador(QThread):
	"Clase encargada de capturar en background los comandos que se envian del Joystick "
	condicion_para_capturar = False		
	def __init__(self,parent):
	super(Capturadorr, self).__init__(parent)
	# QThread.__init__(parent)
	
	def capturing(self,run):
	self.condicion_para_capturar = run
	
	def __del__(self):
	
	self.exit(0)
	
	def capturarComandos(self):
	try:	
	while  True :
	
	if self.condicion_para_capturar:
	eventos = pygame.event.get()	
	for e in eventos:
	# e.type == 7, es un codigo de tipo joymotion
	if e.type == 7: 
	self.emit(SIGNAL('mostrarEje(int,float)'), e.axis, e.value)
	self.emit(SIGNAL('sendManualCmd(int,float,bool)'),\
	e.axis+12, e.value, True)
	if e.type == 10: #Es de tipo JoyButtonDown
	self.emit(SIGNAL('sendManualCmd(int,float,bool)'), e.button, 1.0, False)
	except:
	WindowsError("Error de comando", "Ah ocurrido un error al enviar los comandos" )
	\end{lstlisting}
	
	
	La funci�n \textit{sendManualCmd} posee comandos preestablecidos por el usuario, por lo tanto, cuando se presione alg�n bot�n o se mueva alg�n joystick (palancas) identificado con un id (primer par�metro entero) y su respectivo valor, la clase \textit{Capturador} emitir� una se�al a su respectivo objeto instanciador y proceder� a enviar los comandos pertinentes al veh�culo. Para comprobar dichas funcionalidades �nicamente se ha observado el comportamiento de los motores al girar, ya que al enviar un comando de detenci�n, los mismos respond�an correctamente a dicha acci�n. 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/pComando}
		\caption{Configuraci�n del m�dulo de control manual}
		\label{fig:pcomando}
	\end{figure}
	
	
	
	
	\item \textbf{Control autom�tico: } En este apartado se comprueba el gestionamiento de las misiones, como por ejemplo:  que las mismas puedan ser enviadas y recibidas correctamente por el veh�culo, y que sean debidamente validadas mediante la interfaz gr�fica. Por otro lado, tenemos que verificar que dichas misiones sean ejecutadas por el veh�culo, pero debido a la indisponibilidad de la antena GPS, se tuvieron que posponer dichas pruebas hasta conseguir el componente faltante.
	%TODO: quitar esta parte de la indisponibiidad de la antena
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.17\textheight]{Imagenes/pINICIO_a}
		\caption{M�dulo de control autom�tico del veh�culo}
		\label{fig:pinicioa}
	\end{figure}
	
	
	
\end{itemize}

\subsubsection{Parametrizaci�n}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/pestConfig}
	\caption{Pesta�a de parametrizaci�n del Autopiloto}
	\label{fig:pestconfig}
\end{figure}


El m�dulo encargado de la parametrizaci�n, es simplemente una interfaz gr�fica que muestra las opciones disponibles y configurables del firmware del autopiloto, como se puede ver en la Figura \ref{fig:pestconfig}. Por lo tanto, se valida que esta informaci�n sea mostrada de manera correcta. Adem�s, esta pesta�a perminete modificar los valores de cada parametro, por lo que es necesario validar esta modificaci�n y que sea guardada de forma correcta. Por �ltimo probando que el veh�culo con sus respectivas par�metros modificados se comporte seg�n lo configurado.



\section{Resultados}
% TODO Modificar esto, tengo la antena
Como se pudo ver en las secciones anteriores las pruebas realizadas hasta el momento de los m�dulos pertinentes se han realizado de manera satisfactoria. Se ha realizado una excepci�n respecto de las pruebas de vuelo, que no han sido completamente probadas debido a dificultades en la adquisici�n de la antena GPS. La misma es la responsable de ubicar el veh�culo en un sistema de referencia y el software de autopiloto requiere de esta referencia para poder calcular la trayectoria de regreso, despegar o simplemente moverse. Este inconveniente se solventar� una vez obtenida la antena GPS, luego de su pedido; mientras tanto queda pendiente con el objetivo de proseguir con las actividades del proyecto para cumplir con los tiempos de entrega.
\newpage

\section{Conclusi�n}

Finalmente, luego de haber terminado con la realizaci�n de los distintos tipos de pruebas y comprobar que cada funcionalidad de nuestra aplicaci�n, como tambi�n de nuestro veh�culo est�n funcionando correctamente, llegamos a la conclusi�n de que el \textit{Aseguramiento de la calidad} es un aspecto muy importante en el desarrollo de cualquier tipo de proyecto. 

\par De tal manera, como mencionamos en la introducci�n de este informe,  este proceso se aplica de manera integral desde los inicios del proyecto hasta en las �ltimas etapas; pero cabe destacar que este proceso del \textit{Aseguramiento de la calidad} no ha sido aplicado correctamente cuando comenzamos el proyecto ya que se consideraba una \textbf{p�rdida de tiempo innecesaria}, por lo cual (y como es de esperarse) en etapas posteriores nos encontr�bamos que muchos errores y con que la ``pir�mide estructural'' de nuestro proyecto se sosten�a sobre una base que no era lo suficientemente firme para soportar los niveles superiores de desarrollo del mismo. As� que nos vimos obligados de reformular la estrategia de las etapas siguientes con respecto a las pruebas y adem�s, aplicar dicha t�cnica por primera vez a las etapas iniciales para asegurar que en un futuro la aparici�n de los errores disminuya. De esta manera se ha aprendido, y por lo tanto se incorporar� como ``buenas pr�cticas'', integrar el proceso de QA en proyectos futuros para el cual participe el alumno. 

















