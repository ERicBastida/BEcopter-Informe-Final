% -*-coding: iso-latin-1  -*-
%---------------------------------------------------------------------
%
%                          Capítulo 1
%
%---------------------------------------------------------------------
%
% 01Introduccion.tex
% Copyright 2009 Marco Antonio Gomez-Martin, Pedro Pablo Gomez-Martin
%
% This file belongs to the TeXiS manual, a LaTeX template for writting
% Thesis and other documents. The complete last TeXiS package can
% be obtained from http://gaia.fdi.ucm.es/projects/texis/
%
% Although the TeXiS template itself is distributed under the 
% conditions of the LaTeX Project Public License
% (http://www.latex-project.org/lppl.txt), the manual content
% uses the CC-BY-SA license that stays that you are free:
%
%    - to share & to copy, distribute and transmit the work
%    - to remix and to adapt the work
%
% under the following conditions:
%
%    - Attribution: you must attribute the work in the manner
%      specified by the author or licensor (but not in any way that
%      suggests that they endorse you or your use of the work).
%    - Share Alike: if you alter, transform, or build upon this
%      work, you may distribute the resulting work only under the
%      same, similar or a compatible license.
%
% The complete license is available in
% http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
%---------------------------------------------------------------------

\chapter{Obtención y Análisis de requerimientos}

\begin{FraseCelebre}
	\begin{Frase}
	Frase celebre
	
	\end{Frase}

	\begin{Fuente}
		Autor
	\end{Fuente}

\end{FraseCelebre}

\begin{resumen}
	El presente capítulo contendrá una descripción del desarrollo de las etapas iniciales al proyecto. Como es sabido todo proyecto de cualquier tamaño es recomendable poder llevar una estructura que pueda favorecer el seguimiento y comprobar que este se está llevando a cabo según lo  planificado. Pero antes de iniciar las tareas de desarrollo del proyecto es necesario principalmente definir que es lo que queremos hacer, por tal motivo debemos obtener información de las personas involucradas en el proyecto para saber qué es lo que realmente necesitan y poder obtener las necesidades reales, siempre y cuando sean realizables. Ya obtenido la información de los llamados \textit{stakeholders}, se comienza a realizar modelos iniciales del futuro proyecto con el objetivo de presentarlos a los interesados y corroborar que el modelo  cumple con todos los requerimientos obtenidos, y por lo tanto, empezar a iniciar las etapas de desarrollo.
	De esta manera este capítulo contendrá la descripción del desarrollo de las etapas de obtención y análisis de requerimientos y del Diseño global del sistema que están incluidas en nuestro proyecto y además los inconvenientes  en caso de que se hayan presentado
\end{resumen}

\newpage
%-------------------------------------------------------------------
\section{Introducción}
%-------------------------------------------------------------------
\label{cap1:sec:introduccion}


	La primera etapa de este proyecto consiste en obtener los requerimientos del personal interesado en el desarrollo del mismo (\textit{Stakeholders}), que en nuestro caso son personal del \textit{El Centro de Investigación en Señales, Sistemas e Inteligencia Computacional sinc(i))} la Dra. Marina Murillo, Ing. Lucas Genzeliz, Ing. Nahuel Denis y el Ing. Guido Sánchez.
	
	El proceso de obtención de requerimientos ha consistido en una entrevista con el  personal dónde se ha tenido una charla especificando las necesidades y naturaleza del proyecto y además, se ha presentando las tecnologías disponibles para el desarrollo del mismo. Una vez obtenido los requerimientos, se inicia la actividad de estudiar el campo involucrado del proyecto, con el fin de entender el problema, buscar alternativas, validar y modificar o eliminar requerimientos.
	
	Como la naturaleza del proyecto se origina en la necesidad de un software que pueda comunicarse con un vehículo aéreo no tripulado y además, poder enviarle acciones que puedan ser ejecutadas desde larga distancia tenemos que analizar el campo del \textit{aeromodelismo}, por lo que el ejecutante del proyecto deberá tener los conocimientos necesarios para el mismo. 
	
	Para iniciar con el desarrollo del proyecto es necesario de herramientas; estas ayudan al ejecutante realizar las tareas integradas en cada etapa del proyecto, por lo tanto, es de suma importancia elegir de las indicadas para que el desarrollo se facilite. De esta manera, comenzaremos explicando las herramientas elegidas para el desarrollo del software. 


\begin{itemize}
	
	\item \textbf{Lenguaje de programación Python: } Se trata de un lenguaje de programación multiparadigma, ya que soporta programación orientación a objetos, imperativa y, en menor medida, programación funcional. Es un lenguaje interpretado, usa tipado dinámico y es multiplataforma. Ademas corre con la ventaja de tener una gran cantidad de librerías que son de gran utilidad para el desarrollo de nuestro proyecto.
	
	\item \textbf{PyCharm: } es un entorno de desarrollo integrado (IDE) utilizado en la programación de aplicaciones , específicamente en lenguaje Python . Es desarrollado por la compañía JetBrains. Proporciona análisis de código, un depurador gráfico, probador de unidades integrado, integración con sistemas de control de versiones (VCS) y admite el desarrollo web con Django. Un aspecto importante es que Pycharm es multi-plataforma, con versiones para Windows, Mac OS y Linux; teniendo  disponibles dos versiones, \textit{Professional} y \textit{Community}, siendo esta última la elegida por su utilización gratuita. 
	
	\item \textbf{Qt Designer:} Es un programa (módulo del Framework Qt) para desarrollar interfaces gráficas de usuario y multilenguajes debido a que genera un archivo XML cuyo contenido es el formato del respectivo GUI. Existiendo la posibilidad de convertirlo a Python, que es el lenguaje elegido para el desarrollo del presente proyecto.
	
	
	\item \textbf{PyQtGraph} es una librería gráfica y de creaciones de GUI enteramente construida en Python, basadas en las famosas librerías \textbf{PyQt4} / \textbf{PySide} y \textbf{numpy}. Está destinado para uso en aplicaciones matemáticas / científicas y de ingeniería. A pesar de estar completamente escrito en Python, la biblioteca es muy rápida debido a su gran apalancamiento con numpy para el procesamiento de números y al marco de GraphicsView de Qt para una visualización rápida. Por último, PyQtGraph se distribuye bajo la licencia de código abierto MIT.
	
	\item \textbf{PyQt4: } es una librería gráfica de Qt y realizada bajo Python. Esta librería nos da la opción de poder realizar una interfaz gráfica a nuestra plataforma, para que sea de fácil uso y entendimiento. Además, el software Qt Designer genera código en python utilizando esta libería automáticamente.
	
	\item \textbf{Pygame:} es un conjunto multi-plataforma de módulos de Python	diseñados para la escritura de videojuegos. Incluye gráficos por ordenador y librerías de sonido diseñado para ser utilizado con el	lenguaje de programación Python. Se distribuye bajo la GNU Lesser General Public License. Cuenta con muchos tutoriales, muchos de ellos online.
	
	\item \textbf{Socket:} Al utilizar Python, todos los programas utilizan sockets para lograr comunicarse con otros programas que pueden estar en	diferentes computadoras. Por lo que podemos definirlo como un	objeto que define una conexión entre dos entidades de una red. De esta manera, un socket posee la dirección IP de la máquina, el puerto en el que escucha, y el protocolo que utiliza. Los tipos y	funciones necesarios para trabajar con estos elementos están en el módulo socket de Python.
	
	\item \textbf{Dronekit:} Es una API desarrollada por 3D Robotics en Python, flexible y abierta para el desarrollo de aplicaciones que se ejecutan desde el ordenador de abordo y comunican con el controlador de vuelo ArduPilot con un enlace de baja latencia.
	
	La API se conecta con los drones a través del protocolo de comunicación MAVLink, un sistema utilizado habitualmente para conectar una estación de control de tierra y un vehículo no tripulado para transmitir, por ejemplo, la ubicación y la velocidad. Gracias a este protocolo, la API tiene acceso a los datos de la telemetría a través de Bluetooth, Wi-Fi o el sistema de radio 3DR o a los parámetros del dron y también permite controlar el movimiento y las operaciones del propio aparato no tripulado.
	
	Entre las características destacadas tenemos:
	\begin{itemize}
		\item Desarrollar aplicaciones que mejoran el vuelo en piloto automático.
		
		\item Proporcionar características inteligentes a un dron como la visión por ordenador, la planificación de la ruta o el modelado en 3D.
		
		\item Permitir a un vehículo aéreo seguir objetivos mediante GPS.
		
		\item Facilitar el seguimiento de una ruta marcada con receptores GPS.
	\end{itemize}
	
	
	
	Además es posible instalar en sistemas operativos Linux, Windows y Mac OS X , y la plataforma funciona tanto en ordenadores de escritorio como en móviles. También se puede trabajar con el SDK y acceder a la API en la nube.
	
	
	\item \textbf{Loggin:} Este módulo define funciones y clases que implementan un sistema flexible de registro de eventos para aplicaciones y bibliotecas. Ya que por naturaleza del proyecto estamos utilizando hardware para el desarrollo del mismo, es de suma importancia llevar un registro de los acontecimientos de cada uno, y en caso de generarse algún tipo de inconveniente poder detectarlo con gran facilidad.
	
	\item \textbf{Sphinx: } Sphinx es una herramienta que facilita la creación de documentación de una manera simple e inteligente, escrita por Georg Brandl y bajo la licencia BSD. Originalmente fue creada para la documentación de código escrita en Python, y cuenta con excelentes funcionalidades para la documentación de proyectos de software en varios idiomas. Sphinx se destaca por las siguientes características:
	
	\begin{itemize}
		\item \textbf{Formatos de salida:} HTML (incluida la Ayuda HTML de Windows), LaTeX (para versiones PDF imprimibles), ePub, Texinfo, páginas de manual y texto sin formato.
		\item \textbf{Amplias referencias cruzadas:} marcado semántico y enlaces automáticos para funciones, clases, citas, términos de glosario e información similar.
		\item \textbf{Estructura jerárquica:} fácil definición de un árbol de documentos, con enlaces automáticos a documentos relacionados.
		\item \textbf{Índices automáticos:} índice general así como índices de módulos específicos del idioma.
		\item \textbf{Manejo de código:} resaltado automático utilizando el resaltador de Pygments.
		\item \textbf{Extensiones:} prueba automática de fragmentos de código, inclusión de cadenas de documentación de módulos de Python (documentos API) y más de 50 extensiones contribuidas por usuarios en un segundo repositorio; La mayoría de ellos instalables desde PyPI.
	\end{itemize}
	
	
	
	
\end{itemize}


En lo que concierne a los requerimientos y restricciones del proyecto han sido debidamente escritos en el Documento de Especificaciones de Requerimiento adjuntado en el Apéndice \ref{ap1:ERS}. 





%-------------------------------------------------------------------
\section{Diseño global}
%-------------------------------------------------------------------
\label{cap1:sec:dise}

En esta etapa del proyecto consiste en desarrollar un modelo que mejor represente las necesidades de los interesados y además, que sirva de guía para su respectivo desarrollo. Por tal motivo es necesario seleccionar un modelo que sea de fácil comprensión, con poco lenguaje técnico con el propósito de involucrar en mayor medida a cualquier tipo de \textit{stakeholder} ya que en definitiva ellos determinarán si el producto final satisface sus necesidades y es utilizable. Es por esto, que se decide analizar modelos que representen el proyecto de una forma muy superficial, es decir, una técnica que describa los comportamientos generales del software y  sin entrar en mucho tecnicismo. A raíz de esto y con el conocimiento adquirido en lo que concierne a ingeniería de software se seleccionan dos técnicas, que son:

\begin{itemize}
	\item \textbf{Mockup}.
	\item \textbf{Casos de usos (CU).}
\end{itemize}

La primer propuesta consiste en realizar un bosquejo de la apariencia del software (GUI) y además, incluirle ciertos comportamientos mediante animaciones que den la sensación al usuario de que está utilizando el producto terminado. Por otro lado la segunda propuesta es realizar el modelo comportamental mediante casos de usos, esta técnica consiste en bosquejar un entorno que representa el ámbito donde están las opciones que brindará el sistema con sus respectivos actores o responsables de cada funcionalidad. Analizando las ventajas y desventajas de cada uno se decide utilizar la técnica de \textbf{Mockup} ya que es más representativa al producto real y no utiliza lenguaje técnico; como por ejemplo el utilizado en los CU (\textit{include, extends, entorno y actores}). Para el desarrollo del mockup se utiliza la herramienta \textit{Balsamiq Mockup} \footnote{Utilizando su versión gratuita de 30 días, página web https://balsamiq.com/} y el resultado es anexado en  el apéndice \ref{ap1:GUI}.

\par	Sin embargo, utilizar una técnica que detalle un aspecto superficial y un comportamiento general no ayuda en el inicio de implementación del sistema, es por eso, que en conjunto con el \textit{mockup} y el \textit{ERS} se decide implementar un modelo que ayude y/o simplifique más la tarea de decodificación del software como lo es el \textit{diagrama de clases}. En ingeniería de software, un diagrama de clases dentro de lo que es el Lenguaje Unificado de Modelado (UML) es un tipo de diagrama de estructura estática que describe la estructura de un sistema mostrando las clases del sistema, sus atributos, operaciones, y las relaciones entre los objetos %\citep{sommer}. 
En el apéndice \ref{ap1:classDiagra_v0} se puede ver el respectivo diagrama inicial del software, cabe aclarar que el mismo durante todo el proceso del desarrollo del proyecto ha ido sufriendo cambios que eran necesarios, ya sea por nuevas funcionalidades, complementar las existentes  o simplemente desecharlas ya que no cumplían su respectivo fin. 


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../ManualTeXiS.tex"
%%% End:
