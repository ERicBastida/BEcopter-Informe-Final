%---------------------------------------------------------------------
%
%                          Cap�tulo 3
%
%---------------------------------------------------------------------
%
% 03Edicion.tex
% Copyright 2009 Marco Antonio Gomez-Martin, Pedro Pablo Gomez-Martin
%
% This file belongs to the TeXiS manual, a LaTeX template for writting
% Thesis and other documents. The complete last TeXiS package can
% be obtained from http://gaia.fdi.ucm.es/projects/texis/
%
% Although the TeXiS template itself is distributed under the 
% conditions of the LaTeX Project Public License
% (http://www.latex-project.org/lppl.txt), the manual content
% uses the CC-BY-SA license that stays that you are free:
%
%    - to share & to copy, distribute and transmit the work
%    - to remix and to adapt the work
%
% under the following conditions:
%
%    - Attribution: you must attribute the work in the manner
%      specified by the author or licensor (but not in any way that
%      suggests that they endorse you or your use of the work).
%    - Share Alike: if you alter, transform, or build upon this
%      work, you may distribute the resulting work only under the
%      same, similar or a compatible license.
%
% The complete license is available in
% http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
%---------------------------------------------------------------------

\chapter{Desarrollo de la plataforma}
\label{cap3:desarrollo}

\begin{FraseCelebre}
\begin{Frase}
Frase celebre
\end{Frase}
\begin{Fuente}
Autor
\end{Fuente}
\end{FraseCelebre}

\begin{resumen}
	En este capitulo se describir� todo el proceso realizado de la fase denominada \textbf{Desarrollo de la plataforma}, que forma parte del presente proyecto . En esta fase se contempla las tareas del \textit{Dise�o detallado de la plataforma} y \textit{Codificaci�n} del mismo. En aspectos generales se define de manera un poco m�s especifica y en base al desarrollo global ya realizado en etapas anteriores, todo el comportamiento que incluir� la plataforma, como pueden ser, las funcionalidades de cada m�dulo, la interfaz gr�fica de usuario o por sus siglas en ingl�s (GUI), la l�gica interna correspondiente a cada uno y sus respectivas interacciones. 
\end{resumen}

%-------------------------------------------------------------------
\section{Introducci�n}
%-------------------------------------------------------------------
\label{cap3:sec:Introduccion}

	\par En el �mbito inform�tico, como es sabido, la etapa de codificaci�n del software generalmente es la que m�s tiempo abarca con respecto a la duraci�n total del proyecto. Por esta raz�n, no es de sorprender que a medida que vayamos avanzando  objetivos, herramientas, planificaci�n, dise�o y l�gica del software est�n bajo un constante cambio ya que se van presentando obst�culos, alternativas e incompatiblididades que no han sido previstos en etapas iniciales. De esta manera, se ir�n ilustrando durante este capitulo capturas del estado del proyecto en distintas etapas del mismo, con el objetivo de poder ver el crecimiento y las t�cnicas utilizadas a medida que el proyecto va evolucionando y de esta manera poder aprender, para pr�ximos proyectos, las estructuras que uno debe implementar en etapas iniciales con el fin de no cometer los mismos errores.

\section{Dise�o detallado de la plataforma}
\label{cap3:sec:Disenio_detallado}

\begin{center}
	\begin{minipage}{0.9\linewidth}
		\vspace{5pt}%margen superior de minipage
		{\small
			\textit{Un dise�o de software es una descripci�n de la estructura del software que se va a implementar, los datos que son parte del sistema, las interfaces entre los componentes del sistema y, algunas veces, los algoritmos utilizados.}
		}
		\begin{flushleft}
			(Ian Sommerville, 2005, p71)
		\end{flushleft}
		\vspace{5pt}%margen inferior de la minipage
	\end{minipage}
\end{center}


Antes de iniciar directamente con la codificaci�n, ya que por el mismo instinto de cumplir con las restricciones de tiempo, uno necesita finalizarlo lo antes posible; pero antes que nada es necesario, realizar un dise�o de todo lo que queramos hacer, esto genera una linea de ejecuci�n a seguir que ayuda al ejecutor del proyecto tener planificado las tareas generales que debe realizar en el transcurso del proyecto y no estar pendiente de como proseguir una vez finalizada cada tarea y re-planificar constantemente el hilo del proyecto. Es por tal motivo que el presente proyecto se ha dividido la fase de dise�o en dos, la primera es un dise�o global, meramente con la intensi�n de contar con un panorama general del comportamiento del software/hardware y adem�s, poder mitigar la incertidumbre del ejecutor del proyecto, ya que se est� iniciando en el desarrollo de proyectos de esta envergadura. En base a la documentaci�n que se ha hecho en etapas anteriores podemos empezar a entablar de forma m�s precisa los procedimientos o tareas a realizar, lo que conlleva encarar la segunda parte del dise�o.


\par Seg�n Pressman esta etapa produce los siguientes dise�os:

\begin{itemize}
%	\item \textbf{Dise�o de datos: } El dise�o de datos esencialmente se encarga de transformar el modelo de dominio de la informaci�n creado durante el an�lisis \cite{pressman88is}. En el caso particular de este proyecto el dise�o de datos no juega un papel determinante dado que la herramienta de software propuesta, de la manera en que sea f�sicamente desarrollada e implementada, no requiere moment�neamente estructuras de datos complejas, ni de un esquema de bases de datos como ejemplo.	
%	\item \textbf{Dise�o arquitect�nico: } En el dise�o arquitect�nico se definen las relaciones entre los principales elementos estructurales del programa \cite{pressman88is}. Cuando se habla de elementos estructurales, se hace referencia entidades l�gicas que componen la arquitectura de nuestro dise�o, dentro del abanico de posibilidades de dise�os, podemos seleccionar, diagramas de flujo de datos, modelos de entidad-relaci�n, diagramas de clases, casos de usos entre otros esquemas gr�ficos. Viendo todas estas posibilidades, podemos encarar a dise�ar nuestra estructura con el modelo que m�s se ajuste a nuestras necesidades y sea lo m�s �til posible para las etapas posteriores. Por tal raz�n, es necesario de un dise�o que sea lo m�s representativo posible en el momento de codificaci�n, que utilice un paradigma orientado a objetos , ya que queremos representar objetos como veh�culos, posici�n geogr�fica, Joystick, etc; y que adem�s tengan cada uno sus correspondientes atributos, es por eso que seleccionamos un dise�o orientado a objetos, utilizando lo que anteriormente llamamos \textit{Diagramas de clases}. Estos diagramas son de suma utilidad ya que muestran de manera f�cil como ser� la estructura de nuestro c�digo y sus correspondientes relaciones entre cada uno, con el prop�sito de facilitar la tarea en las etapas posteriores al mismo.	
%	\item \textbf{Dise�o de interfaz: } El dise�o de interfaz describe c�mo se comunica el software consigo mismo, con los sistemas que operan con �l, y con los operadores que lo emplean \cite{pressman88is}. Dentro del aspecto de comunicaci�n de software consigo mismo y con otros sistemas es contemplado en el �tem anterior con el tipo de dise�o elegido. Aqu� lo que nos incumbe es la interacci�n con el operador del software. De esta manera, se selecciona una herramienta que nos permita realizar nuestra interfaz gr�fica del usuario, como por ejemplo, botones, \textit{label}, gr�ficos, \textit{checkboxes}, etc. ayudando al usuario a realizar sus respectivas tareas sin entrar en tanto detalle en comandos espec�ficos  que se debe memorizar con el fin de ser lo m�s amigable posible.
%	\item \textbf{Dise�o procedimental: } El dise�o procedural transforma elementos estructurales de la arquitectura del programa en una descripci�n procedural de los componentes del software \cite{pressman88is}. Para no ser extensos en lo que es el desarrollo de este proyecto y teniendo en mente que el tama�o del mismo no corresponde a uno de grandes dimensiones y  considerando que �nicamente  existe un �nico programador para la etapa de desarrollo, se descarta este tipo dise�o.
\item Item 
\end{itemize}


\par Dentro de lo que es el conjunto de dise�os obtenidos en esta etapa es importante saber en que orden realizar cada una. Ya que cada dise�o esta relacionado directamente con los dem�s, y el desarrollo de uno terminar� condicionando el siguiente. Es por esto, que se analiza la opci�n de comenzar primero con el dise�o de arquitectura. Suponiendo dicha elecci�n se desarrolla el siguiente flujo:

\par En el dise�o orientado a objetos o m�s espec�ficamente, en la confecci�n del diagrama de clases se detallan los objetos mediante bloques gr�ficos denominados clases. Estas clases contienen todos los atributos correspondientes al objeto, como por ejemplo, la clase veh�culo puede contener: cantidad de h�lices, altura de vuelo, velocidad, posici�n, etc. Y adem�s, seg�n este dise�o contiene todas las acciones que puede realizar a trav�s de funciones; si continuamos con el ejemplo de veh�culo a�reo pueden ser: volar, aterrizar, despegar, etc. Esto nos brinda como resultado final una estructura al momento de implementar el c�digo, por lo que facilita la tarea del programador. Adem�s, y un punto importante a tener en cuenta es que muestra como se comunicar� cada clase con las dem�s, esta caracter�stica ayuda a descubrir que funciones extras son necesarias implementar para una correcta cooperaci�n en conjunto. Sin embargo, existe una desventaja, dentro del punto de vista de la interacci�n del usuario, es que no toma en cuenta las funcionalidades que puede desear el usuario para que el uso del software sea m�s placentero (que es el objetivo de este dise�o), sino que el resultado del dise�o se centra en que cada clase pueda responder a las necesidades (mensajes) de las dem�s clases. 


En cambio, si primero realizamos el dise�o de la interfaz gr�fica del usuario, nos determinar� que es necesario entre otros aspectos que no han sido incluido en el dise�o arquitect�nico ya que no se ha tomado como parte importante en el desarrollo, la interacci�n del usuario. Como por ejemplo, funciones de validaci�n de datos, ventanas de advertencias, gr�ficos, como es el HUD (figura \ref{fig:hud}).


\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth, height=0.2\textheight]{Imagenes/hud}
	\caption{Head Up Display}
	\label{fig:hud}
\end{figure}

\par Como podemos ver y seg�n las restricciones presentes, es conveniente realizar primero un dise�o de interfaz, ya que el mismo nos proporcionar� m�s detalles de implementaci�n. Por tal motivo iniciamos primero con el dise�o de interfaz.

\subsection{Dise�o de interfaz}

En primera instancia se inicia con la interfaz gr�fica del usuario o su equivalente en ingles \textit{\textbf{G}raphical \textbf{U}ser \textbf{I}nterface}; por definici�n es el proceso que define como ser� la interacci�n entre el software y el usuario final. Para esto, se utiliza la herramienta Qt Designer, que proporciona mediante un panel de \textbf{widgets} todos los elementos necesarios para el dise�o del mismo. 

\par Para iniciar este proceso, nos basamos en los \textit{mockups}  desarrollados  en la fase de dise�o global de la plataforma, bas�ndonos pantalla por pantalla en la confecci�n de cada uno. Cabe mencionar que las pantallas presentes del dise�o han sido obtenidas luego de un arduo proceso de modificaciones y actualizaciones debido a las necesidades e inconvenientes que se iban presentando en el transcurso de la fase de codificaci�n. Las im�genes de la GUI se pueden ver en el anexo \ref{anexo:GUI}

\subsubsection{Modificaciones generales}
\begin{itemize}
	
	\item \textbf{Inserci�n del HUD en lugar de un mapa} Se ha considerado dise�ar el HUD, en lugar de un mapa. Ya que el mismo no se considera de suma importancia para la navegaci�n en un marco de referencia relativo. La implementaci�n del mapa, se ha documentado como un requisito para las versiones futuras de la plataforma.
	
	\item \textbf{Reemplazo de ubicaci�n de iconos de estados} Los iconos posicionados en la barra superior del software se han reubicados dentro de lo que es el HUD, ya que estos iconos sobrecargaban la aplicaci�n con una constante actualizaci�n siendo que el HUD es el encargado de mostrar dicha informaci�n de manera actualizada.
	
	\item \textbf{Sustracci�n de pesta�a \textit{Sensores}} Seg�n el requisito \textbf{Implementaci�n de calibraci�n de sensores} no se considera para esta versi�n la posibilidad de calibrar los sensores del veh�culo. Si, se incluyen los par�metros del veh�culo y sus respectivos valores en la pesta�a de configuraci�n, con el fin de ser configurados.
	
\end{itemize}



\subsection{Dise�o arquitect�nico}


Luego de finalizar con el dise�o de interfaz y en base al diagrama de clases realizado en etapas anteriores del proyecto, se inicia el modelado m�s detallado del diagrama de clases de nuestro proyecto. Para esto se utiliza de la herramienta ArgoUML, obteniendo el siguiente estructura. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth, height=0.93\textheight]{Imagenes/DC_BEcopter}
	\caption{Diagrama de clases v2, perteneciente al proyecto BEcoper}
	\label{fig:dcbecopter}
\end{figure}

Para el desarrollo del mismo se ha considerado el dise�o de la interfaz gr�fica y de manera complementar�a ,la comunicaci�n que tiene con las dem�s clases conectadas, esto nos facilita al momento de determinar que tipo de funciones necesita cada una y la forma en que se los debe enviar dicha informaci�n.  


\newpage

\section{Codificaci�n y Testing}

En esta etapa consiste en traducir el dise�o en una forma legible por la m�quina. Por tanto, iniciaremos esta tarea seg�n los dise�os de diagrama de clases generados y siempre teniendo en mente los requerimientos estipulados por los \textit{stakeholders}.

\par Seg�n,  la Figura \ref{fig:dcbecopter} tenemos varias clases que se encargar�n de un grupo de funcionalidades en espec�fico y a su vez cada una brinda funcionalidades a sus clases vecinas, para entender un poco el funcionamiento del software comenzaremos explicando cada una, exceptuando las clases que se han utilizado de las librer�as pertinentes.

%ANEXAR CODIGO?

\subsection{Clase Veh�culo}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\linewidth, height=0.2\textheight]{Imagenes/classVehiculo}
	\caption{Clase Veh�culo}
	\label{fig:classvehiculo}
\end{figure}

La clase Veh�culo es la responsable de representar en su mayor medida el objeto real, en nuestro caso es el cuadric�ptero.  Para esto se ha decidido asignarle las siguientes funcionalidades 

\begin{itemize}
	
	\item \textbf{Funciones de vuelo: } Seg�n las restricciones establecidas en el ERS que se han estipulado en primera medida, ya sea por falta de conocimiento de librer�as y/o complejidad de los mismos, �nicamente las siguientes funcionalidades de vuelo \textbf{Ascenso, Descenso y Hovering}; en cambio, gracias a las librerias utilizadas se han codificado m�s funcionalidades correspondientes a las maniobras que puede realizar el veh�culo. Dentro de este conjunto se desarrollaron las siguientes funciones (utilizando el protocolo MAVLink \textit{Micro Air Vehicle Link} y la librer�a Dronekit):
	
	
	\par Cabe mencionar que estas funcionalidades han sido dise�adas con la posibilidad de realizar acciones de vuelo en un marco de referencia global, utilizando las coordenadas globales proporcionadas por el GPS en base a la latitud, longitud y altura (figura \ref{fig:latlong}). Adem�s, es posible establecer sobre un marco de referencia relativo, es decir, este marco de referencia toma como origen el punto inicial de partida del veh�culo, por lo que las coordenadas que ingresemos tendr�n como referencia el punto de despegue. Es importante recordar que el marco de referencia global, conlleva la implementaci�n de un mapa y seg�n el requerimiento R025 este es opcional, e insistiendo con lo mencionado, esta funcionalidad se implementar� en futuras versiones.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/latlong}
		\caption{Marco de referencia global.}
		\label{fig:latlong}
	\end{figure}
	
	
	
	
	\begin{enumerate}
		\item \textbf{Despegar:  } Esta funcionalidad env�a un comando al veh�culo especific�ndole que debe propulsarse gracias a sus motores a una altura en particular.  
		\item \textbf{Aterrizar: } Esta funci�n ordena al veh�culo que aterrice en un punto establecido, dependiendo del sistema de referencia, ya sea global o relativo.
		\item \textbf{Suspenderse: } Seg�n un punto en particular el veh�culo estar� inm�vil y suspendido en el aire por la cantidad de tiempo que se le asigne. Adem�s, esta funci�n entra en el requerimiento R017, donde se establece una funci�n de salvataje encargada de ejecutarse en caso de alg�n inconveniente o percance con el veh�culo y/o conexi�n. 
		\item \textbf{Ir a un punto en especifico: } Como bien su nombre lo especifica, esta orden y seg�n un sistema de referencia le indica al veh�culo que debe desplazarse en un punto en particular. 
		\item \textbf{Volver a inicio: } El veh�culo almacena en primeras instancias su posici�n inicial, asign�ndola en una variable interna llamada \textit{home}, una vez que esta orden ha sido enviada, el veh�culo tratar� de dirigirse a su punto de partida.
		\item \textbf{Moverse: } Seg�n el requerimiento R024, que establece distintos tipos de vuelo se han codificado las funciones de \textit{velocidad} y \textit{yaw} que seg�n las ordenes enviadas de un joystick el veh�culo modificar� su direcci�n en tiempo real,  ya que se han restringido estos comandos a que tengan una duraci�n de ejecuci�n m�nima, dando as� lugar a un nuevo comando y captar las nuevas indicaciones que han sido enviadas por el usuario.
		
	\end{enumerate}
	\item \textbf{Modo de vuelo: }
	Dentro del conjunto de las funcionalidades de vuelo se pueden observar que existen funciones con el prefijo "mis", estos a diferencia de los dem�s, son utilizados cuando el veh�culo se encuentro en modo AUTO, es decir, estos comandos ser�n enviados al veh�culo con el fin de que sean almacenados y ejecutados de manera secuencial misi�n por misi�n cuando se envi� la orden \textit{ejecutar misiones}. Para cumplir de manera complementar�a con el requisito R024, se han codificado funciones que gestionen las misiones pertinentes. 
	
	\item \textbf{Conexi�n: } En base a los requerimientos R015,R016 se han incluido en la clase veh�culo las funciones de \textit{conectado, desconectar y el constructor de la clase} estas son encargadas de conectarse de manera inal�mbrica a una red LAN, gracias a su m�dulo WiFi instalado en la placa Raspberry Pi o de manera ad-hoc mediante m�dulos de comunicaci�n inal�mbrica conectados en un puerto serial. 
	
\end{itemize}


Por �ltimo una funci�n que asigna \textit{Callbacks} a los atributos del veh�culo, ya que estar consultando constantemente los cambios que se est�n produciendo dentro del veh�culo conlleva un consumo extra de recursos,por lo que se decide implementar una funci�n "setCallback2Param" que cada vez que el atributo correspondiente sufra alg�n tipo de cambio, este llame a otra funci�n para informarle de dicha transici�n.


\subsection{Clase Joystick}

La clase Joystick, es la encargada de gestionar dentro del los comandos conectados en el equipo, sus respectivas acciones que han sido ejecutadas por el usuario. \par Con la ayuda de la librer�a Pygame podemos obtener informaci�n de los joystick conectados como nombre, cantidad de botones, n�mero de ejes, si se ha presionado o saltado un bot�n, entre otras acciones, con el objetivo de poder interpretar, seg�n un mapeo de funciones que se han pre-configurado las acciones que desee realizar el usuario en modo manual sobre el veh�culo. Cabe mencionar que dicha clase se ha codificado satisfaciendo los requerimiento R012 y R022.


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\linewidth, height=0.15\textheight]{Imagenes/classJoystick}
	\caption{Clase Joystick}
	\label{fig:classjoystick}
\end{figure}


\newpage
\subsection{Clase Gr�fico Datos}



\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\linewidth, height=0.2\textheight]{Imagenes/classGraficoDatos}
	\caption{Clase gr�ficos de datos o de atributos del veh�culo.}
	\label{fig:classgraficodatos}
\end{figure}

La clase Gr�fico de Datos fue creada con el fin de cumplir con el requerimiento R002 que solicita una representaci�n gr�fica en tiempo real y evolutiva de la informaci�n capturada. Para realizar dicha tarea en primer momento se ha utilizado la librer�a Vispy como la definici�n del requerimiento lo especifica; pero a medida que se iba avanzando en el desarrollo y prueba del mismo se ha encontrado el inconveniente de que dicha librer�a no contiene la documentaci�n actualizada, lo que genera contratiempos al momento de cumplir con el objetivo, por lo que se decide utilizar una librer�a con una comunidad m�s activa, como lo es PyQtGraph. Esta librer�a cuenta con una gran comunidad activa y una documentaci�n detallada de cada funcionalidad disponible, esto facilita mucho al ejecutor del proyecto a dirigir la atenci�n en otros aspectos del proyecto. Cabe destacar que esta librer�a, m�s all� de contener las funcionalidades necesarias para cumplir con el requerimiento estipulado.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.4\textheight]{Imagenes/GD_prueba}
	\caption{Prueba animada en la inserci�n de dato utilizando la Clase Gr�fico Datos.}
	\label{fig:gdprueba}
\end{figure}
Entre el conjunto de funcionalidades disponibles, se describen las m�s importantes:
\begin{itemize}
	\item \textbf{Cupo m�ximo de lineas: } Con fines est�ticos se ha implementado la opci�n de disponer de un n�mero m�ximo de gr�ficos en pantalla, ya que el acumulamiento de gr�ficos sobrecargar� a la aplicaci�n de recursos a consumir y adem�s dejar� de apreciarse cada gr�fica en la ilustraci�n por motivos de espacio. En caso de asignar una nueva linea al gr�fico correspondiente, el mismo eliminar� el primer gr�fico ingresada, utilizando una metodolog�a tipo FIFO.
	\item \textbf{Identificaci�n de lineas: } Para poder gestionar las lineas presentes en el gr�fico es necesario asignarle a cada una un identificador, este identificador adem�s servir� para las clases antecesoras para la inserci�n y eliminaci�n de cada una.
	\item \textbf{Pausado de animaci�n: } Es de esperar que el gr�fico no este disponible tiempo completo, por lo que se decide incorporar la opci�n de pausado de la animaci�n con el prop�sito de optimizar el uso de recursos del equipo y que la aplicaci�n BEcopter sea lo m�s liviana posible.
	
\end{itemize}




\subsection{Clase HUD} %R003

La clase HUD o por su respectiva traducci�n, \textit{visualizaci�n cabeza-arriba}, es la encargada de visualizar al piloto, en este caso el usuario, los datos m�s relevantes del estado del veh�culo, con el objetivo de tener a simple vista el comportamiento del mismo en tiempo real. Por su parte, en el �mbito aeron�utico se utilizan ciertos instrumentos de navegaci�n o s�mbolos que informan al piloto el estado de la aeronave, ya sea, velocidad, altitud, inclinaci�n, etc; que para el desarrollo de esta clase es conveniente saber su significado. Por tal raz�n, explicaremos cada uno de estos instrumentos con su respectiva representaci�n gr�fica.


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\linewidth, height=0.5\textheight]{Imagenes/classHUD}
	\caption{Clase Head Up Display}
	\label{fig:classhud}
\end{figure}

\newpage

\subsubsection{Instrumentos de navegaci�n }
Son los instrumentos esenciales para poder orientarse y seguir la ruta deseada por parte del piloto. \\



\textbf{Horizonte artificial}

\begin{wrapfigure}{l}{0.3\linewidth}
	\centering
	\includegraphics[width=0.8\linewidth]{Imagenes/horizonte_artificial}
	\caption{Horizonte artificial indicando un giro a la derecha en descenso.}
	\label{fig:horizonte_artificial}
\end{wrapfigure}


El horizonte artificial muestra la orientaci�n longitudinal de la aeronave (la relaci�n del eje longitudinal del avi�n con respecto al plano del suelo), es decir: si est� girado, inclinado, con la frente del veh�culo levantado, bajado o todo a la vez. Sirve de gran ayuda en condiciones en que la visibilidad es poca o nula. El horizonte artificial tiene dos partes: el horizonte propiamente dicho, y el indicador de rumbo. El primero est� compuesto por una regi�n azul que representa el cielo, otra normalmente marr�n que representa la superficie terrestre, una mira que representa la direcci�n en que apunta la frente de la aeronave, y varias marcas a su alrededor. Las marcas horizontales a ambos lados representan las alas, el plano de la aeronave, y su �ngulo con el l�mite entre las regiones de cielo y superficie (el horizonte artificial), el cual con dichos planos se produce el �ngulo de alabeo. Dispuestas verticalmente a intervalos regulares, hay marcas horizontales m�s peque�as que representan �ngulos concretos en el plano vertical, a intervalos de 5�, 10�, etc. Muestran el �ngulo actual del eje longitudinal con el plano del suelo. Su principio mec�nico es basado sobre un giroscopio.


\textbf{Indicador de rumbos }

\par El indicador de rumbo, o giroscopio direccional, proporciona al piloto la direcci�n de la aeronave en grados magn�ticos. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.2\linewidth, height=0.2\linewidth]{Imagenes/indicador_rumbo}
	\caption{Indicador de rumbos}
	\label{fig:indicadorrumbo}
\end{figure}


\textbf{Coordinador de Giro}

\par En el coordinador de giro vemos en lugar del bast�n una Figura de un avi�n que nos indica el grado de inclinaci�n de las alas.


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\linewidth, height=0.3\linewidth]{Imagenes/coord_de_giro}
	\caption{Coordinador de giro.}
	\label{fig:coord_de_giro}
\end{figure}

\par Una vez concientizado en los instrumentos de vuelo se procede a integrarlos de manera simulada en un \textit{widget}, con el fin de que cumpla las mismas funcionalidades. Para empezar necesitaremos de una librer�a gr�fica en el cual nos proporcione de funcionalidades para poder graficar estos instrumentos, para eso se selecciona la conocida librer�a OpenGL. Dicha librer�a est� equipada de funcionalidades para dibujar escenas tridimensionales complejas a partir de primitivas geom�tricas simples, tales como puntos, l�neas y tri�ngulos. Adem�s nos d� a disposici�n la personalizaci�n de todos los paramentos que est�n dentro de una escena como posici�n de la luz, c�mara,  tipo de materiales y luces. Pero m�s all� de todo este conjunto de herramientas que nos deja a disposici�n OpenGL, la tarea del dise�o del HUD es realizar en un dibujo en 2D,  el cual se mostraran un conjunto de datos y lineas b�sicas, por lo que se decide no utilizar directamente esta librer�a para el dise�o de la escena, sino que se busca de una \textit{API} en que podamos graficar nuestros instrumentos de navegaci�n de forma m�s sencilla, es por eso, que sea realiza una investigaci�n antes de utilizar dicha librer�a y se encuentra que la librer�a PyQt, en sus conjuntos de clases contiene una de nombre QPainter, m�s all� que internamente usa OpenGL, esta librer�a facilita un conjunto de funciones tales como dibujar elipse, texto, im�genes, lineas, entre otras funcionalidades y de una manera m�s comprensible. De esta forma, abordamos la tarea de graficar  la escena de la siguiente manera: \newline

\begin{enumerate}
	
	\item \textbf{Dibujo del Horizonte Artificial}
	El horizonte artificial como se puede observar en la Figura \ref{fig:horizonte_artificial} est� compuesto por dos rect�ngulos, uno representando el cielo y el segundo la tierra, de esta manera, con la funcionalidad de QPainter que nos proporciona dibujar un rect�ngulo proseguimos a dibujar dos rect�ngulos simulando el horizonte artificial; qued�ndonos como se puede ver en la Figura \ref{fig:hudv0}.
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.3\linewidth, height=0.3\linewidth]{Imagenes/HUD_v0}
		\caption{HUD v0.1}
		\label{fig:hudv0}
	\end{figure}
	
	\par Hasta aqu�, podemos observar que la Figura \ref{fig:hudv0} satisface las necesidades de representar el horizonte artificial seg�n nuestras especificaciones, pero al momento de proyectar al uso del mismo podemos encontrar los siguientes problemas:
	
	\begin{enumerate}
		
		\item \textbf{Problema gr�fico al momento del Roll: } Como se puede ver en la Figura \ref{fig:hudv0e1} , cuando la escena sufre una rotaci�n sobre su eje perpendicular, es decir, simulando un giro sobre el Roll o alabeo del veh�culo, la imagen muestra imperfecciones en las puntas del recuadro. 
		
		\begin{figure}[h]
			\centering
			\includegraphics[width=0.3\linewidth, height=0.3\linewidth]{Imagenes/HUD_v0_e1}
			\caption{Error gr�fico al momento de rotar}
			\label{fig:hudv0e1}
		\end{figure}
		
		\subitem Este problema f�cilmente se puede solucionar ampliando los tama�os de los rect�ngulos en ambas direcciones, considerando siempre el tama�o m�s largo entre el alto y ancho de la pantalla, ya que si no tenemos en cuenta este aspecto cuando tengamos una imagen sumamente apaisada y de poca altura, obtendr�amos el mismo problema. Por tal motivo, se debe elegir un tama�o adecuado para la imagen; ahora la pregunta es �Qu� tama�o debo asignarle a la imagen para que no se presenten dichos defectos? 
		
		
		\textbf{Obtenci�n de la longitud requerida}
		
		\begin{figure}[h]
			\centering
			\includegraphics[width=0.3\linewidth, width=0.3\linewidth]{Imagenes/problemaPuntas}
			\caption{Problema gr�fico en las esquinas}
			\label{fig:problemapuntas}
		\end{figure}
		Como bien muestra la Figura \ref{fig:problemapuntas}, cuando la imagen de fondo sufre una rotaci�n no llega a cubrir lo suficiente los limites de la pantalla, por tanto, se  produce dicho problema. De tal manera se debe buscar la longitud m�xima que debe tener la imagen para que cubra dichos limites, en la Figura  \ref{fig:problemapuntas} se puede apreciar una linea roja que representa el largo necesario a calcular. Este deber� ser la m�nima longitud que deben tener el alto y ancho de la imagen, es decir :
		
		\begin{center}
			$L > Ancho_{Imagenes}  \land L > Alto_{Imagenes}   $ 
		\end{center}
		
		Para calcular dicho valor, se propone implementar una circunferencia con centro en el origen de la pantalla y que tenga un radio por el cual cubra por completo los limites del mismo, como se puede observar en la Figura \ref{fig:problemapuntas2}, de esta manera se contemplan las posibilidades de que la imagen de fondo cubra por completo el dominio de la pantalla en cualquier angulo de rotaci�n que sufra. 
		\begin{figure}[h]
			\centering
			\includegraphics[width=0.3\linewidth, width=0.3\linewidth]{Imagenes/problemaPuntas2}
			\caption{Circunferencia con radio que satisface la longitud requerida.}
			\label{fig:problemapuntas2}
		\end{figure}
		
		\par Por �ltimo, obtener esta longitud se traduce en un problema trigonom�trico  donde se debe obtener la hipotenusa de un triangulo rect�ngulo con base $w/2$ y alto $h/2$. Utilizando el teorema de pit�goras obtenernos que
		
		
		\begin{subequations}\label{eq:longRequerida}
			\begin{align}
			R &= \sqrt{(\frac{w}{2})^2 + (\frac{h}{2})^2}  \\
			R &= \frac{1}{2} (w + h) \label{eq:longRequerida1}
			\end{align}
		\end{subequations}
		
		Como podemos apreciar, la longitud m�nima requerida se obtiene de la ecuaci�n \ref{eq:longRequerida1}. Pero como es de saber, este valor es la longitud total m�nima que debe tener tanto el alto como el ancho de la imagen, por lo que se debe conocer cual es la diferencia al que debemos agregar al ancho, como tambi�n al alto de la imagen. Para esto, simplemente realizamos la diferencia para cada atributo y obtendremos el siguiente valor a agregar
		
		
		\begin{subequations}
			\begin{align}
			Ancho_{aux} &= \frac{1}{2} (h+w) - \frac{w}{2} =  \frac{h}{2} \\
			Alto_{aux} &=  \frac{1}{2} (h+w)  - \frac{h}{2} =  \frac{w}{2} 
			\end{align}
			
		\end{subequations}
		
		\item \textbf{Problema al simular el Pitch: } Otro problema que surge, es al momento de simular el cabeceo o pitch, es que dentro de la escena cuando ocurre este comportamiento el script debe realizar un transformaci�n de traslado, siendo proporcional a la inclinaci�n ocurrida en el veh�culo. Pero en cambio, el defecto que ocasiona es que �nicamente se trasladar�n los dos cuadrados ya dibujados, dejando al descubierto el \textit{background}, como se puede ver en la Figura \ref{fig:hudv0e2}. Adem�s, hay que tener en cuenta que la escena debe permitir un pitch de 0 a 360 grados, por lo que se tendr� que expandir la escena con el fin de simular un entorno virtual 360 en 3D.
		
		\begin{figure}[h!]
			\centering
			\includegraphics[width=0.3\linewidth, height=0.3\linewidth]{Imagenes/HUD_v0_e2}
			\caption{Error al momento de simular el Pitch}
			\label{fig:hudv0e2}
		\end{figure}
		
		Para solucionar este inconveniente surgen las siguientes propuestas 
		
		\begin{enumerate}
			\item \textbf{Mapear una textura al rededor de la c�mara, mediante coordenadas esf�ricas: } En esta propuesta se debe generar una textura de ambiente exterior por el cual ser� mapeada de tal manera que simular� un ambiente 3D. La desventaja de esta propuesta es que la clase QPainter no proporciona funcionalidades para el desarrollo de dibujos en 3D, ni tampoco sus clases antecesoras para el mapeo de textura. Por lo cual, se deber�a codificar la textura manualmente y utilizando las funcionalidades primitivas de OpenGL.
			
			\item \textbf{Inserci�n de rect�ngulos dependientes del Pitch: } Aqu� lo que se pretende es que a medida que el pitch aumente o disminuya, es decir, que el veh�culo cabecee para arriba o abajo, el script interprete estos datos para dibujar un nuevo rect�ngulo contrario al que se ve en pantalla (cielo/tierra), simulando un entorno infinito, como se puede ver en la Figura \ref{fig:addrectangle}.
			
			\begin{figure}[h]
				\centering
				\includegraphics[width=0.4\linewidth, height=0.2\textheight]{Imagenes/addRectangle}
				\caption{Insertando un rect�ngulo perteneciente al piso. }
				\label{fig:addrectangle}
			\end{figure}
			
			Siendo parecer la propuesta m�s efectiva, al momento de realizar las pruebas con el veh�culo se descubre que presenta inconsistencias, ya que el movimiento del pitch no es continuo, por tanto, no se puede ir llevando un seguimiento del cuadro que se esta viendo actualmente para la inserci�n del siguiente. M�s all� de poder emparchar esta propuesta anexando al algoritmo estructuras extras para el seguimiento de los cuadros, el prop�sito del mismo no es acomplejar el problema presente, de esta manera, se recurre al desarrollo de la siguiente propuesta.
			
			\item \textbf{Mapeo del Pitch sobre una imagen: } Finalmente, para solucionar el presente problema, y siempre reduciendo la complejidad a una soluci�n, se propone dibujar una imagen que contenga la escena del horizonte artificial en forma repetida, con el prop�sito de mapear el rango completo del pitch [0 - 360] dentro de una sola imagen, sin estar utilizando im�genes extras para cubran lo restante. 
			
			\begin{figure}[h!]
				\centering
				\includegraphics[width=0.7\linewidth, height=0.5\textheight]{Imagenes/mapeo}
				\caption{Mapeo del horizonte artificial.}
				\label{fig:mapeo}
			\end{figure}
			
			\par Como se puede notar en la Figura \ref{fig:mapeo} el mapeo del pitch corresponder� unicamente al dominio de la pantalla marcada en color rojo. Con esto hacemos referencia, que el mapeo no ser� de forma lineal ya que la entrada del pitch corresponde dentro del dominio de [0 - 360], por lo que se procede a convertirlo en el dominio [-180 - 180] para que sea m�s representativo a la direcci�n que apunta el veh�culo y luego mapearlo al dominio del tama�o de la imagen. La raz�n por la cual se ha tomado el dominio de pantalla especificado, es porque cuando el pitch supere el limite de los 180 (grados), inmediatamente el mapeador deber� llevar "la vista" al rango inferior, es decir, a los -180 (grados), esto dar� al usuario una sensaci�n continuidad de la imagen ya que al sobrepasar, ya sean los limites inferior o superior del dominio de la pantalla, las escenas ser�n pr�cticamente las mismas. 
			
			
		\end{enumerate}
		
	\end{enumerate}% FIN de problemas al momento de dibujar el horizonte 
	
	\item \textbf{Dibujo del �ngulo de banco}
	El �ngulo de banco representa directamente al instrumento de coordinador de giro. Este instrumento indica al usuario la inclinaci�n en el eje x o Roll de la misma forma en que se detall� en su definici�n, con la diferencia que este muestra el rango de inclinaci�n [-(-60), 60] y en caso de sobrepasar este limite se indica con una flecha en color rojo a modo de precauci�n. 
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.4\linewidth, height=0.1\textheight]{Imagenes/angulo}
		\caption{�ngulo de banco.}
		\label{fig:angulo}
	\end{figure}
	
	
	\item \textbf{Dibujo de lineas de referencia}
	Estas lineas de referencia tienen el fin de mostrar al usuario en la pantalla el pitch que esta teniendo el veh�culo en tiempo real, de la misma forma que el �ngulo de banco, este muestra un rango limitado de [-40,40].
	
	\item \textbf{Dibujo de atributos del veh�culo}
	Por �ltimo, se ha tomado la decisi�n de ilustrar dentro del HUD ciertos atributos del veh�culo y conexi�n, que se han considerado importante antes y durante del inicio del despegue. Dentro de estos atributos se han insertado los siguientes elementos como se puede ver en la imagen \ref{fig:hudbeta}
	
	\begin{itemize}
		
		\item \textbf{Indicador de rumbos}
		\item \textbf{Icono de estado de GPS, Se�al y bater�a}
		\item \textbf{Un atributo a elecci�n del usuario} En este caso se ha insertado por defecto el pitch del veh�culo, pero este espacio puede ser ocupado por cualquier atributo del veh�culo. 
		
	\end{itemize}  
	
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\linewidth, height=0.4\textheight]{Imagenes/HUD_beta}
		\caption{HUD final con sus correspondientes atributos e  instrumentos de vuelo.}
		\label{fig:hudbeta}
	\end{figure}
	
	
	
	
\end{enumerate}% FIN de como se dibujaron cada elemento

\newpage


\subsection{Clase Gestor Par�metro}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth, height=0.2\textheight]{Imagenes/classGestParametro}
	\caption{}
	\label{fig:classgestparametro}
\end{figure}

Dentro del veh�culo adem�s de encontrarse con sus atributos tales como: velocidad, posici�n, bater�a, etc. existen par�metros, como bien su nombre lo dice parametrizables, donde es posible establecer o informarse de todo tipo de configuraci�n del veh�culo. Existe una gran variedad de estos, ya que es importante poder configurar cada aspecto de los elementos del veh�culo. Dentro de este conjunto de par�metros podemos clasificaros los siguientes grupos:

\begin{itemize}
	\item \textbf{Armado}
	\item \textbf{Bater�a}
	\item \textbf{Motores}
	\item \textbf{Servo Output}
	\item \textbf{Telemetr�a}
	\item \textbf{IMU}
	\item \textbf{Compas}
	\item \textbf{Barometro}
	\item \textbf{GPS}
	\item \textbf{RC}
	\item \textbf{WayPoint}
	\item \textbf{Misiones}
\end{itemize} %FIX explicar m�s o menos cada grupo

%FIX - explicar como hice para obtener la informaci�n

Donde en cada grupo se encuentran reunidos un conjunto de par�metros individuales que configuran cierto aspecto de cada grupo. Por tal raz�n se decide crear una clase Gesti�n de Par�metro, de tal manera que sea el encargado de agrupar estos par�metros. Para la carga de informaci�n de cada par�metros se ha utilizado una planilla de c�lculo para almacenar la informaci�n, esto es posible gracias a la librer�a \textit{openpyxl} que nos permite ir guardando cada grupo de par�metros en una hoja independiente dentro del documento.
\newpage


\subsection{Clase Par�metro}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\linewidth, height=0.3\textheight]{Imagenes/classParametro}
	\caption{Clase par�metro}
	\label{fig:classparametro}
\end{figure}

Cada par�metro tiene la particularidad dentro del software un conjunto de propiedades que ayudan al usuario a entender su significado y poder modificarlos. Para la creaci�n de dicha clase se han creado las siguientes propiedades:

\begin{itemize}
	\item \textbf{Permiso:     } Este propiedad determina si el par�metro es de solo lectura o es modificable por el usuario. 
	\item \textbf{C�digo:      } Dentro del software se generan c�digos a cada par�metro con el fin de poder enviarlos mediante comandos al veh�culo.
	\item \textbf{Nombre:      } Es una peque�a descripci�n del c�digo, ya que los mismos est�n escritos de forma reducida.
	\item \textbf{Descripci�n: } Describe de manera extendida el significado de cada par�metro y en determinados casos con ejemplos para ayudar al usuario a configurarlos.
	\item \textbf{Rango:       } Los valores m�ximos y m�nimos que puede tomar el par�metro.
	\item \textbf{Incremento:  } Tiene como fin ser una propiedad para configurar un \textit{slider} dentro de cada par�metro en la GUI.
	\item \textbf{Unidades:    } Unidades correspondiente al par�metro.
\end{itemize}
Como es de notar la clase par�metro no almacena su correspondiente valor, esto es debido a que los valores de cada par�metro son tomados del veh�culo cuando se establece la primera conexi�n. Ya que estar manipulando valores cambiantes en dos lugares a la vez pueden producir accidentes al momento de sincronizarlos.

\newpage
\subsection{Clase GUI becopter}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.2\linewidth, height=0.15\textheight]{Imagenes/classGUI_becopter}
	\caption{Clase Graphical User Interface de BEcopter}
	\label{fig:classguibecopter}
\end{figure}

En lo que respecta al proyecto es la clase de mayor tama�o, ya que contiene absolutamente todos los elementos gr�ficos que se pueden ver en BEcopter. Estos est�n desarrollados en base a la creaci�n de un widget padre, con su respectiva est�tica y comportamiento. Una vez definido este widget padre se procede a crear sus correspondientes hijos y una vez finalizados se los inserta en su antecesor. Estos widgets cuentan con una gran variedad de propiedades que puden ser modificadas, y los mismos pueden ser administrados mediante la herramienta Qt Designer (figura \ref{fig:qtdesigner}).

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth, height=0.2\textheight]{Imagenes/qtDesigner}
	\caption{Aplicaci�n QT designer}
	\label{fig:qtdesigner}
\end{figure}


\par Como es de notar BEcopter comprende un gran n�mero de widget, lo que causa que la programaci�n de cada elemento se vuelva engorrosa y consuma tiempo, es por eso que el mismo programa brinda una herramienta que traduce los archivos .ui generados por la aplicacion a archivos .py, que es nuestro lenguaje seleccionado, con el fin de agregarlo directamente al proyecto. Cabe mencionar que dicha herramienta nos d� la facilidad de modificar los aspectos est�ticos de los widget mediante CSS, por lo tanto se ha tenido que estudiar dicha sintaxis y utilizarla para el personalizado de los mismos.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\linewidth, height=0.2\textheight]{Imagenes/ejemploCCS}
	\caption{Ejemplo del dise�o de estilo con CSS.}
	\label{fig:ejemploccs}
\end{figure}






\subsection{Clase BEcopter}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\linewidth, height=0.3\textheight]{Imagenes/classBEcopter}
	\caption{Clase principal BEcopter}
	\label{fig:classbecopter}
\end{figure}

Por �ltimo tenemos la clase principal BEcopter, esta es la encargada de gestionar las dem�s clases presentes en este proyecto. Como podemos observar en el diagrama de clases de la Figura \ref{fig:dcbecopter} la misma est� relacionada con la gran mayor�a por lo que conlleva varias tareas; si detallamos un poco su interacci�n, esta se encarga de:

\begin{itemize}
	
	\item \textbf{Gestionar la interfaz gr�fica: }  La interfaz proporcionada por la clase GUI\_becopter �nicamente representa la GUI, por tanto, este no contiene ning�n tipo de l�gica ni tampoco aspectos din�micos que son de suma importancia para este proyecto. Por lo que es tarea de la clase principal brindarle de dichos comportamientos para poder interactuar con las acciones del usuario; dentro de sus amplias tareas tales como inicializaci�n de estilos, gesti�n de pesta�as, validaci�n de datos, etc.  Tenemos las m�s destacadas que son :
	
	\begin{enumerate}
		
		\item \textbf{Ocultamiento de de opciones: } A modo de seguridad se ha establecido por defecto que al iniciar la aplicaci�n ciertas opciones est�n deshabilitadas, como son las pesta�as de (Inicio y Configuraci�n) ya que estos dependen de que el veh�culo este conectado y en caso contrario, si proporcionamos a que se puedan modificar misiones o par�metros del mismo pueden ocasionar errores.  
		
		
		\item \textbf{Sincronizaci�n de datos: } Poder observar los atributos del veh�culo en tiempo real es de suma importancia, por lo que se definen \textit{timer's} que sincronizan cada cierto periodo de tiempo los valores ubicados en la pesta�a inicio que contiene un conjunto de botones que muestran datos sobre el veh�culo y en la pesta�a conexi�n que presenta informaci�n de su respectiva conexi�n y aspectos generales del veh�culo.
		
	\end{enumerate}
	
	\item \textbf{Gestionar los Joysticks: } Como el fin de BEcopter es poder manejar un �nico veh�culo, se ha restringido a la utilizaci�n de un solo Joystick, pero es importante tener en cuenta que pueden haber m�s de un dispositivo tipo comando conectado al equipo, por lo que se provee de opciones de selecci�n de comandos para contemplar ese aspecto. 
	Adem�s de gestionar la selecci�n del comando a utilizar y realizar el correspondiente mapeo en relaci�n de acci�n-bot�n que ha seleccionado el usuario, este es encargado de captar todos los eventos que se est�n siendo generados en el joystick, con el prop�sito de enviarlos al veh�culo para su posterior interpretaci�n. Esta funci�n es la responsable de realizar el modo manual en caso de ser solicitado.
	
	
	\item \textbf{Gestionar los gr�ficos: }  Dentro de lo que es el proyecto BEcopter est�n incluido un par de gr�ficos que ayudan al usuario a tener presente informaci�n �til del veh�culo y sus sensores. Estos gr�ficos son :
	
	\subitem \textbf{Gr�fico \textit{Head UP Display}}: M�s all� de su propio funcionamiento interno de la clase HUD, la clase BEcopter es la responsable de poder inicializar la conexi�n entre el veh�culo y dicha clase. Por eso es importante que este proporcione los datos necesarios a mostrar cada vez que el atributo sufra un cambio, por tal motivo, es que se generan \textit{callback's} que administran dichos eventos.
	
	\subitem \textbf{Gr�fico de atributos: } La clase veh�culo nos brinda un gran conjunto de atributos que informan sobre el estado del veh�culo, conexi�n, como tambi�n provenientes de los sensores, de tal manera que la clase BEcopter se debe encargar de mostrar dichos atributos en una lista con la opci�n poder agregarlos a la clase gr�fico de datos para su procedente graficaci�n. Adem�s, BEcopter debe proporcionar en dicha lista la opci�n agregar/eliminar atributos tanto en el gr�fico de datos como tambi�n en la botonera.
	
	
	\item \textbf{Gestionar el veh�culo: } La clase veh�culo corresponde al coraz�n del proyecto, ya que este representa de manera directa el UAVs que estamos por manipular, por tal raz�n es importante tener actualizado todos los valores que proporciona la clase veh�culo hacia el usuario; adem�s hay que tener en cuenta que el usuario desear� enviarle comandos al mismo como, despegar, moverse, aterrizar, desplazarse, etc. Ya sea en modo manual mediante el joystick ya selecionado o en forma de misiones, es decir, en modo autom�tico. De esta manera la clase BEcopter para contemplar estos aspectos tendr� que realizar las siguientes tareas:
	
	\subitem \textbf{Sincronizaci�n: } La clase BEcopter tiene la responsabilidad informarle a las clases restantes cuando los atributos que est�n siendo utilizado sufren alg�n tipo de cambio, de esta manera, se han creado un conjunto de conexiones mediante \textit{callbacks} y \textit{timer's} que env�an de manera sincrona y asincrona la informaci�n requerido a cada entidad.
	
	\subitem \textbf{Misiones: } Las misiones son un aspecto importante en BEcopter, ya que proporcionan al usuario la posibilidad de crear un conjunto de comandos parametrizables y que pueden ser enviados al veh�culo para que sean ejecutadas. En lo que concierne a estas opciones tenemos las siguientes utilidades:
	
	\subsubitem \underline{Descargar misiones: } Esta opci�n permite descargar y mostrar en pantalla las misiones que ya tiene almacenado el veh�culo. De manera complementar�a, es una herramienta �til para comprobar que las misiones que han sido enviadas de manera correcta.
	
	\subsubitem \underline{Agregar misi�n: } Agrega una nueva linea en blanco para el ingreso de siguiente misi�n.
	
	\subsubitem \underline{Enviar misi�n: } Esta opci�n tiene la particularidad de �nicamente cargar las misiones en el veh�culo sin la intensi�n de ejecutarlas, ya que puede suceder de enviar misiones incorrectas, por tal motivo BEcopter se encarga de validar dichas misiones y en caso de encontrar un error se le informar� al usuario.
	
	\subsubitem \underline{Iniciar: } Por �ltimo y una vez validada las misiones, BEcopter le env�a la confirmaci�n al veh�culo para que inicie las misiones enviadas.
	
	\subitem \textbf{Estado de conexi�n: } Cumpliendo con el requerimiento R016, que establece la codificaci�n de un script de control del estado de conexi�n, la clase BEcopter se encarga de este aspecto, consultando peri�dicamente dicho estado y en caso de perder la conexi�n (siempre y cuando no se encuentre en vuelo) se bloquear�n las opciones pertinentes al veh�culo, como si estuviera iniciando la aplicaci�n de nuevo. En caso de existir una perturbaci�n en las variables tales como conexi�n, GPS y bater�a, el sistema informar� dicho suceso al usuario para que realice las acciones pertinentes.
	
	\item \textbf{Logging: } Para satisfacer los requerimientos R010 y R011 del documento de especificaci�n de requerimientos la clase BEcopter como tambi�n la clase veh�culo utilizan la librer�a \textbf{logging} de Python para la generaci�n de un logging ya sea de la plataforma o del veh�culo, que se van mostrando en la pesta�a de conexi�n de BEcopter. 
	
\end{itemize}
\newpage


